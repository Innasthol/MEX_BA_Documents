\documentclass[12pt,a4paper,twoside]{article}
\usepackage[left=3.5cm,right=2.5cm,top=1.5cm,bottom=1.5cm,includeheadfoot]{geometry}
\usepackage[onehalfspacing]{setspace}
\usepackage{ngerman}
\usepackage{arial}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage{libertine}
\usepackage{microtype}
\usepackage[font=tiny,labelfont=bf]{caption}
\usepackage{listings}
\usepackage{verbatim} 
\usepackage{color}
\usepackage{pdfpages}
\usepackage{eurosym}

\usepackage{fancyhdr}
\pagestyle{fancy}

\renewcommand{\footrulewidth}{0.4pt}

\renewcommand*{\listoffigures}{%
  \begingroup
  \tocsection
  \tocfile{\listfigurename}{lof}
  \endgroup
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=C++,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=fixed,
	basicstyle={\tiny\ttfamily},
	numbers=none,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=1
}

\begin{document}
	\begin{titlepage}
		\begin{center}
			\huge \bfseries{\scshape{Umsetzung einer objektorientierten Software-Architektur in C++ zur plattformunabhängigen Ansteuerung eines Robotermanipulators}} \\  
			\ \\ 
			\ \\
			\LARGE{ 
				\textbf{
					Bachelorarbeit vorgelegt von \\ 
					Willi Penner \\ 
					Matrikelnummer: 1106136 \\
				}
			}
			\ \\
			\ \\
		\end{center}
		\begin{flushleft}
			Angefertigt im Studiengang Mechatronik \\
			(Bachelor of Science, B. Sc.) \\
			\ \\
			Am Fachbereich Ingenierwissenschaften und Mathematik der Fachhochschule Bielefeld \\
			\ \\
			\ \\
			Tag der Abgabe: 24.07.2020 \\
			Sommersemester 2020 \\
			\ \\
			Erstprüfer: Prof. Dr. rer. nat. Martin Hülse \\
			Zweitprüfer: Prof. Dr. rer. nat. Axel Schneider \\
		\end{flushleft}    
	\end{titlepage}

	%Kopf und Fusszeile
	\lhead{}
	\chead{}
	\rhead{}

	\lfoot{}
	\cfoot{}
	\rfoot{}

	\tableofcontents
		\newpage

	%Kopf und Fusszeile
	\fancyhead[C]{}
	\fancyhead[OL]{}
	\fancyhead[EL]{\leftmark}
	\fancyhead[OR]{\leftmark} 
	\fancyhead[ER]{}

	\lfoot{}
	\cfoot{Seite~\thepage}
	\rfoot{}
	
	\section{Abstract}
		Das Ziel der vorliegenden Bachelorarbeit, die im Fachbereich Ingenierwissenschaften und Mathematik an der Fachhochschule Bielefeld durchgeführt worden
		ist, war die Implementierung einer Softwareschnittstelle um einen Robotermanipulator über einen USB-Anschluss (serielle Schnittstelle) ansteuern zu können.
		Die Ansteuerung des Robotermanipulators soll plattformunabhägig sein, das bedeutet, die Schnittstelle ist unter Windows und unter Linux 
		kompilierbar und nutztbar. \\
		Dazu wird eine vorliegende Software-Architektur auf ihre Vollständigkeit und Objektorientiertheit überprüft und gegebenenfalls angepasst. 
		Im Anschluss wird die Software-Architektur in C++ umgesetzt. 
		\newpage

	\section{Abkürzungsverzeichnis}
		\begin{tabbing}
    		Links \= Mitte \= \kill
    		Abb. \> \> Abbildung \\
    		ILIAS \> \> \textbf{I}ntegriertes \textbf{L}ern-, \textbf{I}nformations- und \textbf{A}rbeitskooperations-\textbf{S}ystem  \\
   			MEX \> \> \textbf{M}odularer \textbf{Ex}perimentierbaukasten \\
   			Zoom \> \> Enterprise-Videokonferenzen mit Instant-Messaging und Content-Sharing \\
   			$\mu s$ \> \> Mikrosekunden (nicht als Zeitangabe, sondern als Positionsangabe)\\
   			$ms$ \> \> Millisekunden \\
  		\end{tabbing}
		\newpage

	\section{Einleitung}
		\sloppy
		Hintergrund dieser Bachelorarbeit ist ein Semesterprojekt aus dem Sommersemester 2019, welches dann im Wintersemester 2019/2020 weitergeführt wurde.
		Das Projekt mit dem Namen "`modularer Experementierbaukasten"' (im weiteren Verlauf mit MEX abgekürzt) hatte zum Ziel einen modularen Roboterbaukasten 
		zu entwickeln, welcher im Rahmen des Moduls Robotik in den Praktika eingesetzt werden soll. Mithilfe des MEX sollen Studierende der Fachhochschule Bielefeld
		erste praktische Erfahrungen in der Roboterprogrammierung sammeln und gelernte Inhalte aus den Vorlesungen in der Praxis anwenden können. \\
		Die Ergebnisse aus diesem Projekt sowie ihre Dokumentation dienen als Ausgangslage für diese Bachelorarbeit. 

		\subsection{Ausgangssituation}
			Zum Beginn der Bachelorarbeit befand sich das zuvor genannte Semesterprojekt kurz vor dem Abschluss. Durch die Projektgruppe ist die Hardware beschafft und 
			die ersten Prototypen aufgebaut worden. Nach der Übergabe der Hardware konnte sowohl der Robotermanipulator als auch eine Teststation für die Servomotoren aufgebaut werden.
			Im folgenden ist die für die Bachelorarbeit bereitgestellte Hardware gelistet: \\
			\ \\
			Hardware der Teststation
			\begin{itemize}
  				\setlength{\itemsep}{0pt}   
				\item[$\bullet$] Controller: Mini Maestro 12-Channel USB Servo Controller (Abb. \ref{fig:Bild1} auf Seite \pageref{fig:Bild1})
				\item[$\bullet$] Servomotoren: Zwei Micro Servo SG90 (Abb. \ref{fig:Bild2} auf Seite \pageref{fig:Bild2}) 
				\item[$\bullet$] Spannungswandler: DC 7-32V to 0.8-28V Adjustable Step Down Power Supply Module Buck Converter (Abb. \ref{fig:Bild1} auf Seite \pageref{fig:Bild1}) 
			\end{itemize}
 			\begin{figure}[htbp] 
  				\centering
     			\fbox{\includegraphics[width=0.4\textwidth]{bilder/Abbildung_1.png}}
  				\caption{Controller und Spannungswandler (Quelle: eigene Aufnahme)}
  				\label{fig:Bild1}
			\end{figure}
			\begin{figure}[htbp] 
  				\centering
     			\fbox{\includegraphics[width=0.4\textwidth]{bilder/Abbildung_2.png}}
  				\caption{Servomotor SG90 (Quelle: eigene Aufnahme)}
  				\label{fig:Bild2}
			\end{figure}
			Hardware für den Robotermanipulator (\ref{fig:Bild3} auf Seite \pageref{fig:Bild3}) 
			\begin{itemize}
  				\setlength{\itemsep}{0pt}   
				\item[$\bullet$] Controller: Mini Maestro 12-Channel USB Servo Controller
				\item[$\bullet$] Servomotoren: Sechs K-Power DM1500 (Abb. \ref{fig:Bild4} auf Seite \pageref{fig:Bild4}) 
				\item[$\bullet$] Diverse mechanische Bauteile für den Aufbau des Robotermanipulators 
			\end{itemize}
			\begin{figure}[htbp]  
  				\centering
     			\fbox{\includegraphics[width=0.4\textwidth]{bilder/Abbildung_3.png}}
  				\caption{Robotormanipulator: Konfiguration mit Greifer (Quelle: eigene Aufnahme)} 
  				\label{fig:Bild3}
			\end{figure}
			\begin{figure}[htbp] 
  				\centering
     			\fbox{\includegraphics[width=0.4\textwidth]{bilder/Abbildung_4.png}}
  				\caption{Servomoter K-Power DM1500 (Quelle: eigene Aufnahme)}  
  				\label{fig:Bild4}
			\end{figure}

		\subsection{Aufgabenstellung}
			Aufgabenstellung der Bachelorarbeit ist die "`Umsetzung einer objektorientierten Software-Architektur 
			in C++ zur plattformunabhängigen Ansteuerung eines Robotermanipulators"' für die bereits angeschaffte 
			Hardware. Dabei Umfasst die Aufgabenstellung:
			\begin{itemize}
  				\setlength{\itemsep}{0pt}   
				\item[$\bullet$] die Analyse und Erweiterung der durch die Projektgruppe erstellte Software-Architektur 
				\item[$\bullet$] die Implementieren der Schnittstelle zur Ansteuerung des Robotermanipulators unter Windows
				\item[$\bullet$] die Portierung der Schnittstelle nach Linux
				\item[$\bullet$] das Testen der Schnittstelle an der Teststation und am Robotormanipulator sowohl unter Windows als auch unter Linux
			\end{itemize}  

		\subsection{Projektorganisation}
			Für die Projektbetreuung ist zu Beginn ein wöchentliches Projektmeeting festgelegt worden. Das Meeting erfolgte über Zoom. Die Meetings dienten dem Projekt
			zugrunde liegenden interativen Entwicklungsprozess. Das bedeutet das sich die Aufgabenstellung von Meeting zu Meeting weiterentwickelt hat. \\
			Um die sich entwickelnde Aufgabenstellung zu dokumentieren ist im ILIAS ein Forum eingerichtet worden. Zusätzlich existiert dort ein Ordner um 
			Projektdateien hochladen zu können. \\
			Unter GitHub ist für die programmierten Sourcefiles ein Repository eingerichtet. Dies dient sowohl dem verfolgen des Projektfortschritts 
			durch den Projektbetreuer als auch der Datensicherung des Quellcodes. Die Kommentierung im Quellcode ist Doxygen-komform (Software-Dokumentationswerkzeug)
			erfolgt, so kann jederzeit mit Hilfe von Doxygen eine Quellcode-Dokumentation generiert werden. 

		\subsection{Eingesetzte Software}
			Für die Durchführung des Projektes und die Erstellung der Bachelorarbeit ist folgende Software eingesetzt worden:
			\begin{itemize}
				\setlength{\itemsep}{0pt}
				\item[$\bullet$] \textbf{Microsoft Visio:} Erstellung des UML-Diagramms
				\item[$\bullet$] \textbf{Eclipse IDE for C/C++ Developers:} Programmierung in C++
				\item[$\bullet$] \textbf{Eclipse TeXlipse 2.0.2:} Erweiterung für Eclipse um LaTeX-Dokumente innerhalb von Eclipse zu erstellen.
				\item[$\bullet$] \textbf{eclox 0.12.1:} Erweitung für Eclipse für Doxygen
				\item[$\bullet$] \textbf{Pololu Maestro Control Center:} Software um die Grundeinstellungen am Microcontroller und den angeschlossenen Servomotoren durchführen zu können.
				\item[$\bullet$] \textbf{Betriebssysteme:} Windows 10 und Ubuntu 18.04.4
				\item[$\bullet$] \textbf{VMware Workstation 15 Player:} Vitualisierung von Linux auf dem Windows-PC
			\end{itemize}
	
	\section{Analyse der Software-Architektur}
		\begin{figure}[htbp] 
  			\centering
     		\fbox{\includegraphics[width=0.9\textwidth]{bilder/Abbildung_5.png}}
  			\caption{UML-Diagramm der Software-Architektur (Quelle: Projektdokumentation MEX-Projekt)}  
  			\label{fig:Bild5}
		\end{figure}
		\noindent Der Abbildung \ref{fig:Bild5} auf Seite \pageref{fig:Bild5} zeigt das UML-Diagramm der Software-Architektur, welches die
		Projektgruppe aus dem Wintersemester 2019/2020 erstellt hat. Bei dem Vergleich des UML-Diagramms und des Quellcodes ist 
		festgestellt worden, das diese sich signifikant Unterscheiden. Die Software-Architektur entspricht nicht den eigentlichen Vorstellungen des Pojektverantwortlichen. \\
		\ \\
		Das UML-Diagramm sieht eine Klasse "`Pololu"' vor, die durch Vererbung die Methoden der Klassen "`IPololu"' und "`ISerialCom"' erhält. Diese
		werden dann wiederrum an die Klasse "`StandardManip.A"' vererbt. Die Klasse "`StandardManip.A"' bietet dem Nutzer die Funktionen eine serielle Verbindung
		zu Öffnen, zu Schließen und Positionswerte für eine Servomotor zu setzen. \\
		Die Namen "`IPololu"' und "`ISerialCom"' suggerieren, dass es sich um Interface-Klassen handelt, dabei handelt es sich um einfache Klassen. Aus dem UML-Diagramm
		ist ebenfalls nicht ersichtlich welche Klassen Attribute enthalten bzw. welche Übergabeparameter die einzelnen Funktionen haben.
		Im Quellcode ist lediglich die Klasse "`IPololu"' umgesetzt, sie enthält die Funktionen um Positionswerte von angeschlossenen Servomotoren zu verändern:
		\begin{lstlisting}[caption={[IPololu]Auszug aus dem Quellcode der Projektgruppe - Klasse: IPololu}]
			unsigned char setTarget(HANDLE port, unsigned char channel,unsigned short target)
			unsigned char setMultipleTargets(HANDLE port, unsigned char numberoftargets, unsigned char channel, unsigned short target)
			unsigned char setSpeed(HANDLE port,unsigned char channel,unsigned short speed)
			unsigned char getPosition(HANDLE port ,unsigned char channel, unsigned int* position)
			unsigned char getmovingstate(HANDLE port)
		\end{lstlisting}
		Die umgesetzten Funktionen sind durch die Nutzung der WindowsAPI nur unter Windows kompilier- und nutzbar. Für die Herstellung der seriellen Verbindung
		wird eine Variable vom Typ HANDLE aus der <windows.h> genutzt. Die Handhabung der seriellen Schnittstelle erfolgt lediglich in einer Funktion. Für die serielle Verbindung
		ist keine Klasse erstellt worden. Der Quellcode, der von der Projektgruppe erstellt wurde, funktioniert zwar um die Servomotoren zu testen und die Funktionsweise
		des Robotermanipulators vorzuführen, entspicht jedoch nicht den gewünschten Anforderung einer objektorientierten Umsetzung. \\
		\ \\
		Aus diesem Grund ist die Software-Architektur überarbeitet worden. In Abb. \ref{fig:Bild6} auf Seite \pageref{fig:Bild6} ist das neue Konzept zu sehen. Die Implementierung und
		die Zusammenhänge werden im nachfolgenden Kapitel behandelt.
		\begin{figure}[htbp] 
  			\centering
     		\fbox{\includegraphics[width=0.99\textwidth]{bilder/Abbildung_6.png}}
  			\caption{UML-Diagramm der neuen Software-Architektur (Quelle: eigene Aufnahme)}  
  			\label{fig:Bild6}
		\end{figure}
	
	\section{Vorgaben durch Hardware}
		\subsection{Funktionsweise der Servomotoren} \label{FunktionServo}
		An dieser Stelle soll nicht die generelle Funktionsweise eines Servomotors erläutert werden, sondern es wird dargestellt, welche Positionsdaten die in diesem Projekt verwendeten Servomotoren
		für das Anfahren einer bestimmten Position benötigt und wie der Zusammenhang zwischen Positionsdaten des Servomotors und der Winkeleinheiten Grad und Radiant ist.\\
		Die Servomotoren werden über ein PWM \footnote[1]{Pulsweitenmodulation: Modulationsverfahren, bei dem eine recheckige Spannung einer gleichbleibenden Frequenz übermittelt wird und
		die Informationen in den verschiedenen Breiten der rechteckigen Pulse codiert ist. (Quelle: Onlinelixikon, https://www.bet.de/lexikon/pulsweitenmodulation/)} angesteuert. Der Winkel eines
		Servomotor wird über die Breite des Pulses bestimmt. Gängig ist ein 50Hz Signal, das entsprichte einer Periodenlänge von 20ms). Diese Einstellungen können im Maestro Control Center für die
		Servomotoren vorgenommen werden. Daraus ergeben sich Positionswerte zwischen 500$\mu s$ (linker Anschlag, $-90^\circ$) und 2500$\mu s$ (rechter Anschlag, $+90^\circ$). Dadurch ergibt sich
		auch die mittlere Position des Servomotors von 1500$\mu s$ (entspricht der Position $0^\circ$). Einige Hersteller schränken diesen Bereich weiter ein, daher ist beim Kauf eines Servomotors
		darauf zu achten, welche Pulseweite sie abdecken. Jedoch ist es ratsam, bei jedem Servomotortyp diese Grenzen durch experemetieren zur ermittlen. So gibt der Hersteller des K-Power DM1500
		über die Pulsweite keine Angaben preis, Händler bewerben eine Pulsweite von 1000-1500$\mu s$. Durch Austesten des Servomotors K-Power DM1500 am Maestro Control Center hat sich gezeigt, dass
		der Servomotor die 500-2500$mu s$ beherrscht. Dies gilt auch für den Testservomotor SG90. Damit kann sich jeder Servomotor am Robotermanipulator um 180$^\circ$ drehen (jeweils $\pm90^\circ$
		von der zentralen Position von 1500$\mu s$ aus). Die Tabelle \ref{tbl:zusammenhaenge} und die Formeln zeigen den Zusammenhang zwischen $\mu s $, Grad und Radiant.
		\begin{table}[h]
     		\centering
			\begin{tabular}{l|c|c|c}
       			\textbf{Einheit} & \textbf{500}$\mu s$ & \textbf{1500}$\mu s$ & \textbf{2500}$\mu s$ \\
       			\hline
       			Grad & $-90^\circ$ & $0^\circ$ & $+90^\circ$ \\
       			Radiant & $-\frac{\pi}{2}$ & $0$ & $+\frac{\pi}{2}$ \\
       			Absolutwert & $6000-3600 $ & $6000$ & $6000+3600$ \\
     		\end{tabular}
     		\caption{Zusammenhang zwischen $\mu s$, Grad und Radiant}
     		\label{tbl:zusammenhaenge}
		\end{table}
		\ \\
		Somit entsprechen 2000$\mu s$ einem Bereich von $180^\circ$. Dadurch ergibt sich ein Umrechnungsfaktor von $\mu s$ in Grad (conFactorPosToDeg) von $ \frac{2000\mu s}{180^\circ} = 11.\overline{1}$.   
		Jedoch hat sich in der Praxis gezeigt, dass sich ein Servomotor, vor allem in einer Preiskategorie \EUR{8-10}, nicht die theoretischen Anschläge hat, die sich aus der Frequenz und der Periodenlänge
		des Signals errechnen lassen. Der K-Power DM1500 stoppt bereits am rechten Anschlag bei 2400$\mu s$ und am linken Anschlag bei 600$\mu s$. Dadurch ergibt sich jedoch ein wesentlich komfortablerer
		Umfrechnungsfaktor (conFactorPosToDeg) von $ \frac{1800\mu s}{180^\circ} = 10$. Mit diesem Umrechnungsfaktor können Servopositionen in $\mu s$ sowohl in Grad als auch in Radiant umgerechnet werden.
		Der Umrechnungsfaktor kann als Konstante in der "`ServoMotor"'-Klasse unter dem Namen "`conFactorPosToDeg"' angepasst werden.\\
		
		Umrechnung von Gradmass in Bogenmass und umgekehrt:
		\begin{eqnarray} \label{DegToRad}
			Gradmass = \frac{180^\circ}{\pi} \times Bogenmass \\
			Bogenmass = \frac{\pi}{180^\circ} \times Gradmass
		\end{eqnarray}
		
		Umrechnung von Servomotorposition in Grad und umgekehrt:
		\begin{eqnarray} \label{MyToDeg}
    		Grad = \frac{\mu s}{conFactorPosToDeg} \\
    		\mu s = Grad \times conFactorPosToDeg
		\end{eqnarray}
		
		Umrechnung von Servomotorposition in Radiant und umgekehrt:
		\begin{eqnarray} \label{MyToRad}
    		Radiant = \frac{\mu s}{conFactorPosToDeg} \times \frac{\pi}{180^\circ} \\
    		\mu s = Radiant \times \frac{180^\circ}{\pi} \times conFactorPosToDeg
		\end{eqnarray}
		
		\subsection{Befehle für den Controller} \label{VorgabePololu}
		Durch die aktuelle Festlegung auf den Mini Maestro 12-Channel USB Servo Controller, sind auch durch diese Hardware bestimmte Vorgaben in der Befehlsnutzung gegeben.
		Die dem Benutzer zur Verfügunggestellten manipulationsmöglichkeite könnne dem Pololu Maestro Servo Controller User's Guide\footnote{https://www.pololu.com/docs/0J40 Stand: 13.07.2020}
		entnommen werden. Als Anlage \ref{usersguide} auf Seite \pageref{usersguide} dieser Bachelorbeit ist lediglich das Kapitel "`5.e Serial Servo Commands"' angefügt. \\
		Ein Befehl, der an den Controller übertragen wird besteht, je nach Befehl, aus 1, 2 bzw. 4 Byte. Folgende Befehle bietet der Controller: \\
	
		\noindent \textbf{Set Target (in hex: 0x84)} Der Befehl "`Set Target"' dient dem setzen eines Positionswertes für den Servomotor, der dann direkt angefahren wird.
		Der Befehl setzt sich aus 4 Bytes (1 Befehlsbyte und 3 Datenbytes) zusammen. Das erste Byte indentifiziert das Kommando, welches der Controller ausführen soll, das zweite Byte gibt das Ziel für den 
		Befehl vor, also welcher angeschlossene Servomotor angesprochen werden soll. Das dritte und vierte Byte enthält die Position, die der Servomotor einnehmen soll
		(aufgeteilt in 0-6 Bits in dritten Byte und die Bits 7-13 im vierten Byte).
		\begin{lstlisting}[caption={[SetTarget]Befehlsaufbau für Set Target}]
			serialBytes[0] = 0x84; // Command byte: Set Target.
			serialBytes[1] = channel; // First data byte holds channel number.
			serialBytes[2] = target & 0x7F; // Second byte holds the lower 7 bits of target.
			serialBytes[3] = (target >> 7) & 0x7F;   // Third data byte holds the bits 7-13 of target.	
		\end{lstlisting}									 
		Dabei erwartet der Controller den Positionswert nicht in $\mu s$ sondern als Absolutwert. Dieser errechnet sich wie folgt:
		\begin{eqnarray}
    		Position = \mu s \times conFactorMyToPos
		\end{eqnarray}
		Der Umrechnungsfaktor von Positionswert in $\mu s$ nach Positionswert als Absolutwert ist durch den Controller vorgegeben und ist vom Betrag 4 (hier und im Quellcode
		mit conFactorMyToPos bezeichnet). Das bedeutet wenn ein Nutzer will, dass der Servomotor seine mittlere Position von 1500$\mu s$ anfahren soll, muss über
		den Befehl Set Target der Wert 6000 ($1500\mu s \times 4$) übergeben werden. \\
		
		\noindent \textbf{Set Speed (in hex: 0x87) und Set Acceleration (in hex: 0x89)} Die Befehle Set Speed und Set Acceleration sind ebenfalls wie Set Target aufgebaut.
		Der Befehl ist 4 Byte groß. Die Infomationen in den Bytes entsprechen dem Befehl von Set Target, jedoch erwartet der Controller als Geschwindigkeits- bzw.
		Beschleunigungswert einen Wert zwischen 0-255. \\
		Dabei steht 1 als Geschwindigkeitswert für die langsamste Geschwindigkeit des Servomotors und 255 für die Höchste. Ausnahme bildet die 0, sie steht für
		"`unlimited speed"', also das Maximum, das der Servomotor leisten kann. Einen sichtbaren bzw. mit einfachen Mitteln meßßbaren Unterschied zwischen den Werten 0 und 255 gibt
		es nicht. Daher ist in der Umsetzung der Befehle in C++ auf die 0 verzichtet worden. Es werden nur Werte von 1-255 zugelassen und es kommt auch nicht zu Geschwindigkeitssprüngen,
		wenn z.B. der Wert innerhalb einer Schleife erhöht bzw. verringert wird. Gleiches gilt für den Befehl der Beschleunigung. \\ 	
		
		Berechnung von Geschwindigkeit bzw. Beschleunigung:
		\begin{eqnarray} \label{SpeedAcceleration}
    		Geschwindigkeit = Geschwindigkeitswert(1-255) \times \frac{0.25\mu s}{10ms}  \\
    		Beschleunigung = Beschleunigungswert(1-255) \times \frac{0.25\mu s}{10ms \times 80ms}
		\end{eqnarray}
		
		\noindent \textbf{Get Position (in hex: 0x90)} Der Befehl Get Position veranlasst den Controller einen Rückantwort bereitzustellen, die von der seriellen Schnittstelle 
		gelesen werden kann. Der Befehl Get Position besteht nur aus 2 Bytes (1 Befehlsbyte und 1 Datenbyte).
		\begin{lstlisting}[caption={[GetTarget]Befehlsaufbau für Get Target}]
			serialBytes[0] = 0x90; // Command byte: Get Target.
			serialBytes[1] = channel; // First data byte holds channel number.
		\end{lstlisting}
		Damit weis der Controller von welchem Servomotor er den Positionswert bereitstellen soll. Der Postitionswert der vom Controller zurückgeliert wird, ist im gegensatz
		zum Set Target nicht als Absolutwert, sondern kommt in $\mu s$ direkt vom Servomotor. Das bedeutet, um in der Programmierung nicht in den Einheiten durcheinander
		zu geraten, muss der, von der Funktion Get Position, zurückgelieferte Wert mit dem Umrechnungsfaktor (conFactorMyToPos) multipliziert werden. \\   	
		
		\noindent \textbf{Get Moving State (in hex: 0x93)} Dieser Befehl ist nur 1 Byte groß und enthält damit nur das Befehlskommando an den Controller. Der Controller 
		antwortet dann mit einer 1 oder 0. Solange sich irgend ein angeschlossener Servomotor noch bewegt, liefert dieser Befehl als Antwort eine 1, stehen \underline{alle} 
		Servomotoren still, dann liefert der Befehl als Antwort die 0. \\
		
		Wie die Abfrage der Rückantwort erfolgt wird im Abschnitt \ref{ISerialCom} auf Seite \pageref{ISerialCom} näher erläutert.
			
	\section{Implementierung der Software-Achritektur}
		Für die Implementierung der Schnittstelle ist entschieden worden unter Windows die WindowsAPI zu nutzen (\#include <windows.h>) und unter Linux die File Control Options in der "`\#include <fcntl.h>"'.
		Die Entscheidung fiel nach Einarbeitung in das User's Guide von Pololu, welches auch Beispielcode für die Nutzung der Serial Commands sowohl unter Windows als auch unter Linux bot. Der Quellcode aller
		implementierten Header- und Sourcefile sind dem Anhang bzw. der beiliegenden DVD zu entnehmen. \\
		Die Fehlerbehandlung in den einzelnen Methoden der Klassen erfolgt über "`throw"'-Ausdrücke, diese können vom Bentuzer oder von einer später darüber liegenden Schicht mit "`try" und "`catch"' aufgefangen und
		ausgewertet werden.
				
		% Bild der neuen Softwarearchitektur
		\subsection{ISerialCom/SerialCom} \label{ISerialCom}
			Für das Handling der seriellen Schnittstelle ist ein Interface "`ISerialCom"' definiert und die zugehörige Klasse "`SerialCom"' implementiert worden 
			(Quellcode siehe Anhang \ref{SerialComHPP} auf Seite \pageref{SerialComHPP}). Das Interface setzt vier grundlegende Funktionen voraus, die in
			einer von ISerialCom abgeleiteten Klasse umgesetzt werden müssen. Dabei handelt es sich um folgende funktionen:
			\begin{lstlisting}[caption={[ISerialCom]Auszug aus dem Headerfile SerialCom.hpp: ISerialCom}]
				class ISerialCom {			
				public:
					virtual ~ISerialCom(){};
    				virtual void initSerialCom(const char* portName, unsigned short baudRate) = 0;
    				virtual bool openSerialCom() = 0;
    				virtual bool closeSerialCom() = 0;
    				virtual bool writeSerialCom(unsigned char command[], unsigned short sizeCommand, unsigned char *response, unsigned short sizeResponse) = 0;
				};
			\end{lstlisting}
			Die Funktion "`iniSerialCom"' dient dem initialisieren einer seriellen Verbindung. Dazu werden der Funktion der Portname (z.B. "`COM4"' unter Windows oder "`/dev/ttyACM0"')
			und die Baudrate mit der die serielle Verbindung arbeiten soll übergeben. Mit den Funktionen "`openSerialCom"' und "`closeSerialCom"' lässt sich die 
			serielle Verbindung öffnen bzw. schliessen. Zusätzlich bekommt der Nutzer von den Funktionen ein Feedback, ob der gewünschte Vorgang erfolgreich war, 
			oder ein Fehler aufgetreten ist.\\
			Die Funktion "`writeSerialCom"' dient dem Übertragen von Befehlen an den angeschlossenen Controller (in diesem Fall ein Mini Maestro 12-Channel USB Servo Controller). 
			Auch hier bekommt der Nutzer das Feedback über erfolgreiches oder fehlerhaftes Übertragen von Befehlen. Als Übergabeprameter bekommt die Funktion
			den Schreibbefehl für den Controller (command) und die Größe dieses Befehls in Bytes (sizeCommand). Handelt es sich um reine Schreibbefehle ist "`response"' gleich NULL und die 
			Größe von "`sizeResponse"' ist gleich Null, da keine Antwort vom Controller erwartet wird. Bei Befehlen, die eine Antwort erwarten wird "`response"' als Zeiger auf ein
			Feld vom Typ "`unsigned char"' übergeben und die "`sizeResponse"' ist dann, je nach Antwortgröße, 1 bzw. 2 Byte gross. \\
			Die Übertragung eines zusammengesetzen Befehls, wie in Kapitel \ref{VorgabePololu} auf Seite \pageref{VorgabePololu} beschrieben, erfolgt unter Windows mit dem Befehl "`WriteFile"' 
			(unter Linux mit "`write"'). Ist die Variable "`sizeResponse"' gleich 0, wird keine Antwortet vom Controller erwartet. Ist der Wert 1 bzw. 2 wird eine Antwort erwartet. Der Controller
			stellt aufgrund des Befehl, der Über das "`WriteFile"' übertragen wurde, eine Antwortbereit, die jetzt noch über "`ReadFile"' bzw. "`read"' über die serielle Schnittstelle gelesen
			werden muss. Im Falle einer Abgefragten Position ist die Antwort 2 Byte groß und im Falle einer Abfrage des Bewegungsstatus ist die Antwort 1 Byte groß.
			\ \\
			Von diesem Interface ist die Klasse "`SerialCom"' abgeleitet. In dieser sind die Funktionen vom Interface implementiert. Die Klasse "`SerialCom"' erhält die privaten Member für 
			den Portnamen und die Baudrate. Als dritten Member hat die Klasse die serielle Verbindug "`port\_"' selbst. Um den Quellcode von Vorherein sowohl für Windows als auch für Linux 
			kompilierbar zu halten, ist mit dem Kontrukt
			\begin{lstlisting}[caption={[IFDEF]\#ifdef}]
				#ifdef _WIN32
        			// Quellcode für Windows
        			HANDLE port_;
    			#else
        			// Quellcode für Linux
        			int port_;
    			#endif
			\end{lstlisting}
			sowohl der Quellcode für Windows als auch für Linux in der selben Klasse und den selben Funktionen untergebracht. Über "`\#ifdef"' wird sichergestellt, dass während der Kompilierung
			nur der für das aktuelle Betriebssystem relevate Code übersetzt wird. Für die serielle Verbindung wird "`port\_"' als HANDLE
			definiert und unter Linux als Integer. Mit diesem Interface und der dazugehörigen Klasse kann eine serielle Schnittstelle etabliert werden und damit eine Verbindung
			zum Servocontroller hergestellt werden.
			
		\subsection{IPololu / Pololu}
			Um die Servomotoren ansteuern zu können ist ein weiteres Interface "`IPololu"' definiert und die Klasse "`Pololu"' implementiert worden 
			(Quellcode siehe Anhang \ref{PololuHPP} auf Seite \pageref{PololuHPP}).
			\begin{lstlisting}[caption={[IPololu]Auszug aus dem Headerfile Pololu.hpp: IPololu}]
				class IPololu {
				protected:
					virtual bool setPosition(unsigned short servo, unsigned short goToPosition) = 0;
					virtual bool setSpeed(unsigned short servo, unsigned short goToSpeed) = 0;
					virtual bool setAcceleration(unsigned short servo, unsigned short goToAcceleration) = 0;
					virtual unsigned short getPosition(unsigned short servo) = 0;
				public:
					virtual ~IPololu(){};
    				virtual bool getMovingState() = 0;
				};
			\end{lstlisting}
			Das Interface "`IPololu"' definiert die Funktionen, die es dem Nutzer erlauben, Servomotoren am Controller anzusteuern. Dabei können die Position, Geschwindigkeit und Beschleunigung
			eines Servomotors gesetzt werden. Desweiteren bietet das Interface eine Funktion, die die aktuelle Position des Servomotor liefert. Diese genannten Funktionen sind im Interface und auch 
			in der Klasse "`Pololu"' als "`protected"' gesetzt. "`Public"' ist lediglich die Funktion "`getMovingState"', diese liefert den Bewegungsstatus der angeschlossenen Servomotoren. Stehen 
			\underline{alle Servomotoren} still, liefert die Funktion den Wert "`0"', befindet sich noch \underline{auch nur ein Servomotor} in Bewegung, liefert die Funktion den Wert "`1"'. \\
			\ \\
			Die vom Interface abgeleitete Klasse "`Pololu"' steht mit der Klasse "`SerialCom"' in einer Aggregationsbeziehung. Das bedeutet, dass ein Objekt vom Typ "`SerialCom"' als "`protected Member"'
			teil der Klasse Pololu ist. Damit ist es möglich mit einem erzeugten "`Pololu"'-Objekt eine serielle Verbindung zu etablieren. Dazu ist die Klasse "`Pololu"' mit "`public"'-Funktionen erweitert,
			die es ermöglichen eine serielle Verbindung zu initialisieren und diese dann öffnen und schließen zu können. Die Funktionen "`initConnection"', "`openConnection"' und "`closeConnection"' 
			rufen die equivalenten Funktionen des Objekts "`serialCom"' auf. Somit kann zuerst von außerhalb der Klasse "`Pololu"' nur auf die zum Verbindungsaufbau notwendigen Funktionen 
			zugegriffen werden. Im nächsten Abschnitt wird darauf näher eingegangen. Für die Ansteuerung eines Controllers ist damit ein Pololu-Objekt notwendig.
			
		\subsection{IServoMotor/ServoMotor}  
			Die dritte Inferface-Klasse-Kombination dient dem erzeugen von Servomotor-Objekten (Quellcode siehe Anhang \ref{ServoMotorHPP} auf Seite \pageref{ServoMotorHPP}).
			Jeder angeschlosse Servomotor wird in C++ durch ein Objekt der Klasse "`ServoMotor"' representiert.
			\begin{lstlisting}[caption={[IServoMotor]Auszug aus dem Headerfile ServoMotor.hpp: IServoMotor und ServoMotor}]			
				class IServoMotor {
				public:
					virtual ~IServoMotor(){};
					virtual unsigned short getServoNumber() = 0;
					virtual unsigned short getMinPos() = 0;
					virtual unsigned short getMidPos() = 0;
					virtual unsigned short getMaxPos() = 0;
					virtual bool setPositionInAbs(unsigned short newPosition) = 0;
					virtual bool setPositionInDeg(short newPosition) = 0;
					virtual bool setPositionInRad(float newPosition) = 0;
					virtual bool setSpeed(unsigned short newSpeed) = 0;
				    virtual bool setAccelaration(unsigned short newAcceleration) = 0;
					virtual unsigned short getPositionInAbs() = 0;
					virtual short getPositionInDeg() = 0;
					virtual float getPositionInRad() = 0;
					virtual void showPololuValues (unsigned short& min, unsigned short& mid, unsigned short& max) = 0;
				};
			
				class ServoMotor : public IServoMotor{
				private:
					const short maxDeg = 90;				//maximum degree allowed
					const float maxRad = M_PI/2;			//maximum radiant allowed, M_PI is the constant from <cmath> for the number Pi
			    	const short maxSpeed = 255;				//maximum value for the speed
					const short maxAcceleration = 255;      //maximum value for the acceleration
					const short minSpeed = 1;				//minimum value for the speed
					const short minAcceleration = 1;        //minimum value for the acceleration
					const short conFactorDegToPos = 10;	    //conversion factor from degrees to position
					const short conFactorMyToPos = 4;		//conversion factor to convert microseconds (position value of a servo) to position values
			    	unsigned short servoNumber_;
					unsigned short startingPosition_;	    //startPosition is the center position of a servo, in most cases it is value of 6000 (1500microseconds * 4)
					unsigned short delta_;
					Pololu *connection_ = NULL;
				public:
					ServoMotor(unsigned short servo, unsigned short startingPosition, unsigned short delta, Pololu *connection);
			\end{lstlisting}
			Bei dem Erzeugen eines Objektes vom Typ "`ServoMotor"' muss dieser zwingend über den Kontruktor mit Übergabeparametern initialisiert werden.
			Über den Konstruktor wird dem Objekt, die Servonummer (Anschlussport auf dem Controller. Für den hier genutzten Mini Maestro 12-Channel USB Servo Controller
			sind es die Anschlüsse 1-12), die Startposition (damit ist die mittlere Position des Servomotors gemeint, die als Ausgangslage für Bewegungen dient), ein Delta
			(gibt den Positionsbereich an, den der Servomotor nach Links und Rechts von der Startposition aus drehen kann) und als Zeiger wird dem Servomotor-Objekt
			die serielle Verbindung in Form des Pololu-Objektes, mitgegeben. \\
			Das Servomotor-Objekt bietet dem Nutzer alle Manipulationsmöglichkeiten die der Servo-Controller unterstützt. Die Klasse "`ServoMotor"' greift dazu auf die 
			Funktionen des Pololu-Objektes zurück. Allerdings wäre das nicht ohne weiteres Möglich, da die benötigten Funktionen in der Klasse "`Pololu"' "`protected"' sind.
			Damit die Klasse "`ServoMotor"' die Funktionen dennoch nutzen kann ist in der Klasse "`Pololu"' die Klasse "`ServoMotor"' als "`friend class"' definiert, damit 
			kann aus der Klasse "`ServoMotor"' auf die "`protected"' Funktionen der Klasse "`Pololu"' zugegriffen werden. \\
			Damit ist sichergestellt, das aus der Main-Klasse oder einer anderen Stelle des Programmes wo ein Objekt vom Typ "`Pololu"' erzeugt wird, zwar auf die Funktionen
			zugegriffen werden kann um eine serielle Verbindung zu etablieren, die angeschlossenen Servomotoren jedoch nur von einem "`ServoMotor"'-Objekt manipuliert werden
			können. \\
			Desweiteren enthält die Klasse "`ServoMotor"' notwendige Parameter für die Festlegung von Grenzen und Umrechnung von Positionswerten. Wie bereits in Kapitel \ref{FunktionServo}
			auf Seite \pageref{FunktionServo} erwähnt, arbeitet der Servomotor intern mit Positionsangaben in $\mu s$. Dem Nutzer werden durch die Klasse "`ServoMotor"' drei
			Möglichkeiten für die Positionsangabe geboten. 
			\begin{description}
				\item[setPositionInAbs:] Mit dieser Funktion ist es möglich die Positionsangabe für den Servomotor in absoluten Werten anzugeben. Durch die Vorgabe des Controller 
										 bedeutet dies, wenn z.B. der Servomotor seine mittlere Position von 1500$\mu s$ anfahren soll, erwartet der Controller vom Benutzer einen
										 Positionswert von 6000 ($1500\mu s \times 4$). Dadurch ergibt sich ein Arbeitsbereich für den Servomotor von 6000 (als mittlere Position)
										 $\pm$ 3600.
			    \item[setPositionInDeg:] Eine zweite Möglichkeit ist das Setzen der Position durch Angabe der Position in Grad. Durch die Konstante "`maxDeg"' wird der Bereich der
			    						 möglichen Eingaben auf einen Bereich von $\pm 90 ^\circ$ eingeschränkt. Die Einschränkungen erbegen sich durch die Bauweise der Servomotoren.
			    						 Dadurch das der Controller einen Positionswert als Absolutwert zwischen 2400 und 9600 erwartet muss innerhalb der Funktion zuerst die
			    						 Gradzahl in den Absolutwert umgerechnet werden. Der Factor für die Umrechnung ist 10 (conFactorDegToPos). 
			    						 Zuerst wird die Gradzahl in Absolutwert umgerechnet und das Ergebnis im Anschluss zur mittleren Position
			    						 addiert bzw. substrahiert (je nach Vorzeichen der Gradzahl).
			    \item[setPositionInRad:] Die dritte Möglichkeit ist die Eingabe einer Position in Radiant. Durch die Konstate "`maxRad"' wird der Bereich
			    						 der möglichen Eingaben auf einen Bereich von $\pm\frac{\pi}{2}$ eingeschränkt. Hier muss zuerst der Radiant in Grad und im anschluss
			    						 in den Positionswert umgerechnet werden. Die Formeln dafür sind auf der Seite \pageref{DegToRad} zu sehen.
			\end{description}		
			Mit Hilfe der Funktion "`getPosition"' kann der aktuelle Positionswert eines Servomotors erfragt werden. Auch in diesem Fall kann sich der Nutzer den aktuellen
			Positionswert als Absolutwert, als Gradmass bzw. als Bogenmass geben lassen. Hier nochmal der Hinweis, dass der Positionswert, der vom Controller 
			als Rückgabewert geliefert wird, in $\mu s$ ist und erst noch in den Absolutwert umgerechnet werden muss. Die Besonderheit des Controllers ist, er liefert den Positionswert
			in $\mu s$, erwartet aber zum setzen einer neuen Position den Wert als Absolutwert. Hier ist Vorsicht geboten. Daher hat der Nutzer nur die drei Möglichkeiten 
			Positionswerte anzugeben (Absolutwert, Grad, Radiant). Positionswerte in $\mu s$ kann der nutzer nicht verwenden. \\
			Lediglich über die Funktion "`showPololuValues"' kann der Nutzer sich vom "`ServoMotor"'-Objekt die Minimum-, Mittel- und Maximalposition als Wert in $\mu s$ anzeigen lassen.
			Dies dient der Überprüfung der Einstellungen im Maestro Control Center. Für jeden neuen Servomotor müssen zuerst Einstellungen im Maestro Control Center getätigt werden. Sie 
			erfolgen ausschließlich in $\mu s$. Damit der Nutzer überprüfen kann, ob die Einstellungen die er dem "`ServoMotor"'-Objekt mit den Einstellungen im Maestro Control Center
			übereinstimmen, steht ihm die Funktion "`showPololuValues"' zur Verfügung. \\	
			Die Methoden "`getMinPos"', "`getMidPos"' und "`getMaxPos"' liefern dem Nutzer Informationen darüber, wie die Einstellungen für ein bestimmtes "`ServoMotor"'-Objekt sind.
			Die Positionswerte, die diese Funktionen liefert sind Absolutwerte. Sie errechnen sich aus den bei der initialisierung des Objektes angegebenen Werten für die
			Mittlere-/Ausgangsposition mit dem dazugehörenden Delta (Schwänkbereich nach Links und Rechts). \\
			Die Set- und Get-Methoden der "`ServoMotor"'-Klasse können aufgrund ihrer "`friend class"'-Beziehung zur "`Pololu"'-Klasse auf dessen Private bzw. durch "`protected"' geschützte 
			Methoden zugreifen.		
			
		\subsection{Testen der implementierten Klassen}
			Um die Funktionalität der implementierenten Klassen "`SerialCom"', "`Pololu"' und "`ServoMotor"' zu testen, ist ein weiteres Header- und Sourcefile angelegt worden (TestUnits.hpp, 
			Quellcode siehe Anhang \ref{TestUnitsHPP} auf Seite \pageref{TestUnitsHPP}). Das Sourcefile "`TestUnits.cpp"' enthält aktuell 7 Funktionen um die Funktionalität der Schnittstelle zu testen.
			\begin{enumerate}
				\item Eine Funktion Namens "`wait"'. Bei dieser Funktion handelt es sich um eine Hilffunktion, die bei der Nutzung
				      der Servomotoren dafür genutzt wird um das ablaufende Programm zu stoppen und eine bestimmte Zeit abzuwarten.
				      Damit Servomotoren die Chance haben Bewegungen zu ende auszuführen, bevor sie einen neuen Befehl erhalten.
				      Ähnlicher Effekt wird mit folgender Codezeile erreicht:
				      \begin{lstlisting}[caption={[Wait] Aufforderung zum Warten}]			
				      		while(conn.getMovingState());
				      \end{lstlisting}
				      Diese Zeile sorgt im Quellcode dafür, dass der nächste Befehl erst aufgeführt wird, wenn \underline{alle} Servomotoren 
				      wieder stillstehen. Solange dies nicht der Fall ist, begindet sich das Programm in einer Schleife in der nichts getan wird.
				      "`conn"' ist dabei das "`Pololu"'-Objekt, welches die serielle Verbindung zum physikalischen Controller ist.
				\item Die Funktion "`testOpenClose"' dient dem Test der seriellen Verbindung selbst. In dieser Funktion werden unterschiedliche
					  Tests mit der Verbindung durch geführt:
					  \begin{itemize}
					  	\setlength{\itemsep}{0pt}
							\item[$\bullet$] Definieren eines "`Pololu"'-Objektes
							\item[$\bullet$] Öffnen der definierten Verbindung
							\item[$\bullet$] Öffnen der selben bereits offnen Verbindung
							\item[$\bullet$] Schließen der Verbindung
							\item[$\bullet$] Schließen derselben bereits geschlossenen Verbindung 
							\item[$\bullet$] Neu initialisieren des "`Pololu"'-Objektes mit einem unbekannten Portnamen und öffnen dieser Verbindung
							\item[$\bullet$] Neu initialisieren des "`Pololu"'-Objektes und mehrfachen Öffnen der Verbindung hintereinander (100x)
					  \end{itemize}
					  Mit diesen Test wird das Verhalten des "`Pololu"'-Objketes getestet und überprüft, ob es dem gewünschten Verhalten entspricht.
					  Als ein Beispiel sei hier das Öffnen einer Verbindung genannt. Eine bereits geöffnete Verbindung zu einem COM-Port kann nicht 
					  erneut geöffnet werden. Um sicherzustellen, das es nicht dazu kommen kann, wird zu beginn der "`openSerialCom"'-Funktion die
					  Verbindung pauschal geschlossen. Damit ist sichergestellt, dass sich das Öffnen nicht doppelt.
				\item In der Funktion "`testSetGetMethods"' wird das Schreiben und Lesen auf den Controller durch die Klassen "`ServoMotor"', "`Pololu"' und 
				      "`SerialCom"' überprüft. \textbf{HINWEIS:} Diese Funktion darf nur in der Testumgebung ohne zusammengebauten Robotermanipulator getestet
				      werden. Dieser Hinweis ist auch im Quellcode und der Doxygen-Dokumentation vermerkt.
				\item Desweiten existieren zwei Funktionen (testMEXMovementSetting1 und testMEXMovementSetting2), die dem Test 
					  am Robotermanipulator dienen. \textbf{HINWEIS:} Gründliches lesen der Doxygen-Dokumentation, da vor der Verwendung dieser Funktion
					  der Robotermanipulator auf eine bestimmte Weise zusammengesetzt sein muss und Einstellungen im Maestro Control Center vorgenommen werden müssen.
					  Die erste Version dient dem Test des Robotermanipulators mit angebautem Greifer. Die Funktion lässt den Robotermanipulator eine
					  Box auf dem Untergrund ansteuern, hebt diese dann an und platziert sie an einer anderen Stelle. Die Version 2 ist mit dem 
					  Stifthalter ausgestattet und fährt mit dem Stift 5 unterschiedliche Punkte auf dem Papier an. \textbf{HINWEIS:} Auch für diesen 
					  Test sind umbauten und anpassungen der Einstellungen notwendig.
			    \item Für den Einzeltest der Klasse "`SerialCom"' ist die Funktion "`testSerialCom"' vorhanden. Diese Testet die Funktionen der Klasse, initialisieren 
			    	  einer seriellen Verbindung mit und ohne Nutzung des Konstruktors, Öffnen und Schließen der Verbindung, sowie das Schreiben und Lesen.
			   	\item Die Funktion "`testPololu"' dient dem Test der Klasse "`Pololu"' vor allem, ob der Zugriff auf die "`protected"'-Funktionen möglich ist.
			\end{enumerate}
			
		\subsection{Aufbau des Robotermanipulators}
			Um die implementierte Schnittstelle zu testen ist der Robotermanipulator in zwei unterschiedlichen Varianten aufgebaut und getestet worden. \textbf{HINWEIS:}
			Die beiden Testfunktionen "`testMEXMovementSetting1"' und "`testMEXMovementSetting2"' in den TestUnits-Files dürfen nur mit den, in den nächste beiden Abschnitten
			beschriebenen Konfigurationen verwendet werden. Die Benutzung in einer anderen Konfiguration kann zu beschädigungen sowohl an mechanischen Bauteilen wie
			auch an den Servomotoren führen. Es ist sinnvoll jede neue Aufbaukonfiguration zuerst mit dem Maestro Control Center zu testen und die Grenzen für die Servomotoren
			auszuloten und für die Nutzung festzuschreiben. \\
			\ \\
			Der Grundaufbau ist für beide Konfigurationen identisch.
			Die beiden Aufbauonfigurationen für den Robotermanipulator erfolgten nicht zu hundert Prozent nach der Aufbauanleitung der Projektgruppe des Wintersemester 2019/2020
			(Aufbauanleitung ist im Anhang \ref{Aufbauanleitung} auf Seite \pageref{Aufbauanleitung} zu finden). 
			Der Aufbau in der Anleitung sieht für die Konfiguration mit dem Greifer einen Aufbau mit 5 Servomotoren vor. Dies ist aktuell nicht möglich.
			Die Installationsbox, die die Stromversorgung und den Controller beinhaltet bietet nur Anschlüsse für 4 Servomotoren (Abb. \ref{fig:Bild7} auf Seite \pageref{fig:Bild7}). 
			\begin{figure}[htbp] 
  				\centering
     			\fbox{\includegraphics[width=\textwidth]{bilder/Abbildung_7.png}}
  				\caption{Installationsbox (Quelle: eigene Aufnahme)}  
  				\label{fig:Bild7}
			\end{figure}
			Dieser Aufbau beinhaltet zwei Grundplatten. Sie werden miteinander verschraubt. Auf die Grundplatten wird mittig der Grundträger geschraubt. Auf den Grundträger
			wird dann noch eine Servoscheibe befestigt. Die Begriffe wie Grundplatte, Grundträger und Servoscheibe sind der Aufbauanleitung entnommen um im gleichen
			Sprachgebrauch zu bleiben. Diese können in der Aufbauanleitung nachgelesen werden.
			
			\subsubsection{Konfiguration 1: Mit Greiferarm}
				Für den Aufbau mit des Robotermanipulators mit Greifarm werden 4 Servomotoren (K-Power DM1500) benötigt. Einer wird mit 
				mit einem Arm vom Typ 2 ausgestattet, 2 Servomotoren bekommen den Arm Typ 1 und der vierte Servomotor wird mit dem Greiferarm (Zusammenbau des Greiferarms ist der
				Aufbauanleitung zu entnehmen) verbunden. \\
				\begin{figure}[htbp] 
  					\centering
     				\fbox{\includegraphics[width=\textwidth]{bilder/Abbildung_8.png}}
  					\caption{Robotermanipulator mit Greifer - Draufsicht (Quelle: eigene Aufnahme)}  
  					\label{fig:Bild8}
				\end{figure}
				\begin{figure}[htbp] 
  					\centering
     				\fbox{\includegraphics[width=\textwidth]{bilder/Abbildung_9.png}}
  					\caption{Robotermanipulator mit Greifer - Seitenansicht (Quelle: eigene Aufnahme)}  
  					\label{fig:Bild9}
				\end{figure}
				\noindent Dabei sollten bei dieser Ausrichtung alle Servomotoren auf ihre mittlere Position eingestellt sein (1500$\mu s$ bzw. 6000 als Absolutwert. Jedoch sollten diese
				Einstellungen zu Begin im Maestro Control Center in $\mu s$ erfolgen). Dabei ergeben sich bauteilbedingte Probleme. Abb. \ref{fig:Bild11} verdeutlicht eines 
				der Schwierigkeiten.
				\begin{figure}[htbp] 
  					\centering
     				\fbox{\includegraphics[width=0.4\textwidth]{bilder/Abbildung_11.png}}
  					\caption{Positionierung eines Servomotors am Robotermanipulator (Quelle: eigene Aufnahme)}  
  					\label{fig:Bild11}
				\end{figure}
				Aufgrund der Positionierung der Servoscheibe auf dem Grundträger bzw. auf einem Arm und der Verzahnung in der Servoscheibe, in die der Servomotor mit seiner 
				ebenfalls verzahnten Achse eingesetzt wird, lässt sich der Arm in seiner Mittelstellung (1500$\mu s$) nicht gerade einsetzen. Das Soll ist die Ausrichtung wie in Abb. \ref{fig:Bild11} B		
				gezeigt. Jedoch lässt sich der Servomotor in der Stellung 1500$\mu s$ nur wie in Abb. \ref{fig:Bild11} A oder C einsetzen. Um die Position der Servomotor in
				die Stellung B zu bringen, muss er wie in A bzw. C eingesetzt werden und über das Maestro Control Center auf Position B gedreht werden. \\
				So ergibt sich in diesem Fall, dass die mittlere Position des ersten Servomotors nicht 1500$\mu s$ sind, sondern bei 1420$\mu s$ bzw. 1580$\mu s$ liegt 
				(dies entspricht einem Versatz von ca. 8$^\circ$). Das Vorgehen muss für alle Servomotor nacheinander wiederholt werden. Daraus ergeben sich die Einstellungen, 
				die bei der Erzeugung der "`ServoMotor"-Objekte über den Kontruktor mitgegeben werden. \\
				Weiterhin ist darauf zu achten, dass die Ausrichtung wie in Abb. \ref{fig:Bild8} gezeigt, nicht als Ausgangslage für die Nutzung der Schnittstelle dienen sollte.
				Solange die Servomotoren mit Strom versorgt sind bleiben sie in der eingestellten Position. Wird der Robotermanipulator vom Strom genommen, sackt der Arm am Übergang
				von Arm Typ 2 auf Arm Typ 1 Aufgrund des Eigengewichts ab und schlägt auf die Grundplatte auf. Beim wieder Einschalten werden die Servomotoren mit der Infomation
				ihrer zuletzt eingestellten Position versorgt und der Arm reist ruckartig nach oben, so dass der gesamte Robotermanipulator in Bewegung gerät. Daher ist es ratsam zu 
				Begin und zum Ende der Nutzung den Robotermanipulator in eine Parkposition zu bringen (z.B. wie in Abb. \ref{fig:Bild10} auf Seite \pageref{fig:Bild10}).
				\begin{figure}[htbp] 
  					\centering
     				\fbox{\includegraphics[width=0.4\textwidth]{bilder/Abbildung_10.png}}
  					\caption{Robotermanipulator mit Greifer - Parkposition (Quelle: eigene Aufnahme)}  
  					\label{fig:Bild10}
				\end{figure}
				Der zweite Servomotor wird dazu auf die Position $startingPosition + 90^\circ$ gebracht. Dadurch bleibt der Robotermanipulator in der gleichen Position, 
				auch wenn er vom Strom genommen wird. Ebenso verharrt der Arm beim Einschalten in der selben Position. \\
				Weiterhin ist in Abb. \ref{fig:Bild9} auf Seite \pageref{fig:Bild9} zu sehen, dass der Arm des zusammengesetzten Robotermanipulators über die Grundplatte hinausragt.
				Dem kann durch anbringen zweier weiterer Grundplatte im vorderen Bereich entgegengewirkt werden. \\
				Nach dem Aufbau und der Konfiguration der Einstellungen im Maestro Control Center konnte der Robotermanipulator mit der "`testMEXMovementSetting1"' getestet werden.
				Auf der beiliegenden DVD kann im Ordner "`Videos"' das Video "`Konfiguration\_A.mp4"' des Tests angeschaut werden.
			
			\subsubsection{Konfiguration 2: Mit Stifthalter}
				Für den Aufbau des Robotermanipulators mit Stifthalter werden 4 Servomotoren (K-Power DM1500) benötigt. Der Aufbau erfolgt nach Aufbauanleitung. 	
				Es werden drei Arm Typ 1 und ein Arm Typ 2 und der Stifthalter benötigt. Zuerst werden zwei Typ 1 Arme montiert, gefolgt von einem Typ 2 und im Anschluss erneut ein
				Typ 1 Arm mit dem Stifthalter (Abb. \ref{fig:Bild12} auf Seite \pageref{fig:Bild12}). Der Bleistift ist durch einen Whiteboardmarker ersetzt worden, dadurch reicht
				bereits eine leichte Berührung auf dem Papier um eine Markierung zu setzen.
				\begin{figure}[htbp] 
  					\centering
     				\fbox{\includegraphics[width=\textwidth]{bilder/Abbildung_12.png}}
  					\caption{Robotermanipulator mit Stifthalter - Seitenansicht (Quelle: eigene Aufnahme)}  
  					\label{fig:Bild12}
				\end{figure}
				Mit der Testfunktion "`testMEXMovementSetting2"' wird der Robotermanipulator mit Stifthalter gestestet. Der Robotermanipulator fährt dazu 6 Punkte
				auf einem Papierblatt an und setzt jeweils einen Punkt, wobei Punkt 1 und 6 von den Einstellungen der Servomotor identisch sind. Der Test kann ebenfalls im Ordner "`Videos"' 
				(Konfiguration\_B.mp4) als Videoaufname angeschaut werden. Im Video sowie in der Abb. \ref{fig:Bild13} auf Seite \pageref{fig:Bild13} fällt ein weiteres Problem
				des Robotermanipulators auf. 
				\begin{figure}[htbp] 
  					\centering
     				\fbox{\includegraphics[width=0.6\textwidth]{bilder/Abbildung_13.png}}
  					\caption{Robotermanipulator mit Stifthalter - Abweichungen (Quelle: eigene Aufnahme)}  
  					\label{fig:Bild13}
				\end{figure}
				Trotz gleicher Einstellungen liegen die Punkte 1 und 6 nebeneinader und nicht wie erwartet übereinander. Diese Abweichung ist Geschwindigkeitsabhängig. 
				Sowohl die Videoaufnahme als auch die Abb. \ref{fig:Bild13} zeigen das Ergebnis mit einem eingestellten Geschwindigkeitswert von 30 für alle Servomotoren. Das entspricht einer
				Geschwindigkeit von $30 \times \frac{0.25\mu s}{10ms} = 0.75 \frac{\mu s}{ms}$. Wird die Geschwindigkeit auf den Wert 10 reduziert 
				($10 \times \frac{0.25\mu s}{10ms} = 0.25 \frac{\mu s}{ms}$) liegt die Abweichung nur noch bei $1-2mm$. Je langsamer die Servomotoren drehen, desto präziser kann ein bestimmter
				Punkt angesteuert werden. Der Effekt triff auf, weil jeder Arm des Robotermanipulators aufgrund seiner Kontruktion ein Spiel von $2-4mm$ hat. Das führt dazu dass der 
				gesamte Robotermanipulator am Stifthalter ein Spiel von $8-16mm$, sowohl in horizontaler als auch in vertikaler Richtung, hat. 
				Dies führt zu ungenauen Ansteuerungen bei höherer Geschwindigkeit.  
				
	\section{Fazit und Ausblick}
		Ziel der Bachelorarbeit ist die "`Umsetzung einer objektorierten Software-Architektur in C++ zur plattformunabhängigen
		Ansteuerung eines Robotermanipulators"' gewesen. Die Umstrukturierung der Software-Architektur ist in Zusammenarbeit mit dem
		Projektverantwortlichen durchgeführt worden. Die unterschiedlichen Aufgaben der Schnittstelle sind gegliedert und in Klassen
		aufgeteilt worden.
		\begin{description}
			\item[Steuerung der seriellen Verbindung:] Zusammengefasst im Interface "`ISerialCom"' und der dazugehörigen Klasse "`SerialCom"'.
			\item[Befehlsübertragung an den Controller:] Zusammengefasst im Interface "`IPololu"' und der dazugehörigen Klasse "`Pololu"'.
			\item[Steuerung der Servomotoren:] Zusammengefasst im Interface "`IServoMotor"' und der dazugehörigen Klasse "`ServoMotor"'.
		\end{description}
		Durch die Testfunktionen ist gezeigt worden, dass die einzelnen Elemente der Schnittstelle funktionsfähig sind. Die implementierte Schnittstelle ermöglicht 
		dem Nutzer eine serielle Verbindung mit Hilfe eines "`Pololu"'-Objektes herzustellen. Objekte für die angeschlossenen Servomotoren (ServoMotor) zu erstellen und die Servomotoren
		über diese zu steuern. Die Funktionsweise ist in Bild und Ton dokumentiert. \\
		\ \\
		Für die Realisierung der Schnittstelle war, das zu Begin der Bachelorarbeit vereinbarte interative Vorgehen bei der Aufgabenstellung, ein enormer Vorteil. Die schrittweise
		Entwicklung der Schnittstelle führte dazu die Problemstellung in einzelne Bereiche zu gliedern und diese einzeln und fokussiert zu betrachten. \\
		\ \\
		Ein weiterer Vorteil für die Entwicklung war, dass der Robotermanipulator von der Projektgruppe bereits fertig war und für die Testung bereitgestellt wurde.
		Dadurch war es zu jeder Zeit möglich den aktuellen Vortschritt zu testen und zu erkennen an welchen Stellen der gewünschte Effekt noch nicht auftritt. \\
		\ \\
		Herausforderung bei der implementierung ist die Quellcodedokumentation gewesen. Den Quellcode zeitnah, verständlich und nachvollziehbar zu dokumentieren ist nicht 
		immer einfach gewesen oder schlicht weg vergessen worden. Dies wurde allerdings nachgeholt und der Quellcode liegt jetzt dokumentiert vor.
		\ \\
		Die Zusammenarbeit mit dem Projektverantwortlichen (auch wenn nur über Zoom) ist sowohl für den Fortschritt der Arbeit als für die persönliche Weiterentwicklung
		sehr bereichernd gewesen. \\
		\ \\
		Sicherlich ist am Robotormanipulator einiges Verbesserungsfähig und es besteht das Potential der Weiterentwicklung (Spiel der Servomotoren in den Servoscheiben). 
		Er lässt jedoch bereit gut und einfach für simple Aufgaben einsetzen. Es können mit Hilfe der implentierten Schnittstelle vom Robotermanipulator mit Greifer leichte 
		Gegenstände bewegt werden. Mit dem Stifthalter können auf Papier einzelne Punkte angefahren werden. Für genaueres Zeichnen, z.B. von geometrischen Figuren, 
		erfordert es noch einer oder mehrerer zusätzlicher Schichten in der Implementierung. In der nächsten Ebene müssten die einzelnen Servomotoren und deren Grenzwerte in 
		Beziehung zu einander gesetzt werden, damit z.B. wenn Servomotor um seinen Maximalradius nach unten gedreht ist, dass sich der an ihm hängede Servomotor nicht mehr 
		auf seinen Maximalwert nach unten drehen lassen, weil der Arm die Grundplatte berühren würde. Akuell bewegen sich alle Servomotoren unabhängig von einander und 
		es muss akribisch darauf geachtet werden, dass es nicht zu Beschädigungen kommt. \\
		Bei vorsichtiger und vorausschauender Handhabung ist der Robotermanipulator mit der implementierten objektorientierten Schnittstelle einsatzfähig. 	
		\newpage

	% Abbildungsverzeichnis
	\listoffigures
		\newpage

	% Eidesstattlische Versicherung
	\section{Eidesstattliche Versicherung}
		Ich erkläre hiermit an Eides Statt, dass ich die vorliegende Arbeit selbständig und ohne 
		Benutzung anderer als der angegebenen Hilfmittel angefertigt habe. Die aus fremden Quellen 
		direkt oder indirekt übernommenen Gedanken sind als solche kenntlich gemacht. \\
		\ \\
		\ \\
		\ \\
		\ \\
		\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ \\ 
		(Willi Penner) \\
		\newpage

	\section{Inhalt des Datenträgers}
		Auf dem beiliegenden Datenträger (DVD) liegen alle zur Bachelorarbeit gehörenden Videos, Bilder, Quellcodes und weitere Dokument vor.
		Ordnerstruktur:
		\begin{itemize}
			\setlength{\itemsep}{0pt}
			\item[$\bullet$] Enthält die Bachelorarbeit im PDF-Format.
			\item[$\bullet$] \textbf{Videos:} Enthält die beiden Videos der Test des Robotermanipulators mit Greifer (Konfiguration\_A) und mit Stifthalter (Konfiguration\_B).
			\item[$\bullet$] \textbf{Bilder:} Enthält sowohl Bilder, die in der Bachelorarbeit verwendet wurde, als auch weiter Aufnahmen des Robotermanipulators bzw. der Einzelteile.
			\item[$\bullet$] \textbf{Quellcode:} Enhält die Quellcodefiles des Projektes.
			\item[$\bullet$] \textbf{Latex:} Enthält die LaTeX-Datei der Bachelorarbeit und die der Bachelorarbeit angehängte Dokumente im PDF-Format. 
		\end{itemize}
	
	% Anhang der Bachelorarbeit
	\appendix
		\section{Anhang}
			% Datenblatt Servo SG90 
			\subsection{Datenblatt MicroServo SG90}
				\includegraphics[page=1,width=\textwidth]{sg90_datasheet.pdf} 
				\newpage
			% Datenblatt Servo DM1500
			\subsection{Datenblatt Servo K-Power DM1500}
				Ein Datenblatt für den Servomotor K-Power DM1500 ist im Netz nicht auffindbar gewesen. Die
				Informationen in nachfolgender Tabelle entstammen der Webseite des Herstellers: \\
				https://m.kpower.com/product/products\_rc\_servo\_airplane\_servos/DM1500.html (Stand: 10.07.2020)
				\includegraphics[page=1,width=0.7\textwidth]{dm1500_datasheet.pdf}
				\newpage 
			% Datenblatt Servo SG90 
			\subsection{Pololu Maestro Servo Controller User's Guide (Seiten 54-58)} \label{usersguide}
				\includegraphics[page=1,width=\textwidth]{maestro54.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{maestro55.pdf}
				\newpage  
				\includegraphics[page=1,width=\textwidth]{maestro56.pdf}  
				\newpage	
				\includegraphics[page=1,width=\textwidth]{maestro57.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{maestro58.pdf}  
				\newpage
			% Interface ISerialCom
			\subsection{Quellcode: Headerfile von ISerialCom und SerialCom} \label{SerialComHPP}
				\begin{lstlisting}[caption={[ISerialCom] Interface: ISerialCom - Klasse: SerialCom}]
					//=======================================================
					// Name        : SerialCom.hpp
					// Author      : Willi Penner
					//
					// Description : SerialCom header file. It contains the 
					//               declaration of the ISerialCom interface 
					//               and the SerialCom class
					//=======================================================
					#ifndef SERIALCOM_HPP_INCLUDED
					#define SERIALCOM_HPP_INCLUDED

					#ifdef _WIN32
    					#include <windows.h>
					#else
						#include <iostream>
					#endif

					/** \brief Interface for a serial connection via a COM port
 					*  Prescribes at least the included pure virtual functions 
 					*  for initiating, opening, closing and writing a serial 
 					*  connection.
 					*/
					class ISerialCom {
					public:
						virtual ~ISerialCom(){};
    					virtual void initSerialCom(const char* portName, unsigned short baudRate) = 0;
    					virtual bool openSerialCom() = 0;
    					virtual bool closeSerialCom() = 0;
    					virtual bool writeSerialCom(unsigned char command[], unsigned short sizeCommand, unsigned char *response, unsigned short sizeResponse) = 0;
					};

					/** \brief SerialCom is a class that inherits the 
					*  functions from the ISerialCom interface. The 
					*  functionality of the interface is expanded by
					 *  the function getPort ().
 					*
 					*  \param portName_ : The port name is used to open 
 					*  a serial connection via the port name for the 
 					*  controller specified by the operating system.
 					*  \param baudRate_ : The baud rate determines the 
 					*  transmission speed at which communication between 
 					*  the PC and controller takes place.
 					*  \param port_ : If a serial connection is opened 
 					*  successfully, depending on the operating system, 
 					*  a HANDLE (under Windows) or an integer value 
 					*  (under Linux) is defined, via which the communication 
 					*  takes place.
 					*/
					class SerialCom : public ISerialCom {
					private:
    					const char* portName_ = NULL;
    					unsigned short baudRate_ = 0;
    					/**< depending on the operating system, a HANDLE 
    					 (under Windows) or an integer value (under Linux) 
    					 for an open connection */
    					#ifdef _WIN32
        					HANDLE port_;
    					#else
        					int port_;
    					#endif
					public:
    					/* Constructors: A constructor without 
    					   transfer parameters, so that when used in the 
    					   Pololu class or another class, an object of 
    					   type SerialCom can be created without having 
    					   to pass values to it. And a constructor for 
    					   creating an object with start parameters for 
    					   the port name and the baud rate.
     				   	   portName : The port name is used to 
     				   	   open a serial connection via the port name 
     				   	   for the controller specified by the operating 
     				   	   system.
     			       	   baudRate : The baud rate determines 
     		           	   the transmission speed at which communication 
     				   	   between the PC and controller takes place.
     				   	*/
    					SerialCom();
    					SerialCom(const char* portName, unsigned short baudRate);

					    /** \brief "initSerialCom" is used to initiate 
					    *  the SerialCom object with port name and baud rate.
     				   	*  The function puts the object in the same state 
     				   	*  as the constructor with transfer parameters.
     				   	*  It can be used to change the port name and the 
     				   	*  baud rate of a SerialCom object.
     				   	*
     				   	*  \param portName : The port name is used to 
     				   	*  open a serial connection via the port name 
     				   	*  for the controller specified by the operating 
     				   	*  system.
     				   	*  \param baudRate : The baud rate determines 
     				   	*  the transmission speed at which communication
     				   	*  between the PC and controller takes place.
     				   	*/
    					void initSerialCom(const char* portName, unsigned short baudRate);

    					/** \brief Uses the set port name and the baud 
    					*  rate of the class to open a serial connection.
     					*  If the opening is successful, the value in 
     					*  "port_" stands for the open connection and
     					*  can be used for communication.
     					*
     					*  \return Returns TRUE on successful opening 
     					*  of a serial connection, otherwise it returns
     					*  FALSE.
     					*/
    					bool openSerialCom();
					
    					/** \brief Closes a serial connection.
     					*
     					*  \return Returns TRUE on successful closing 
     					*  of a serial connection, otherwise it returns 
     					*  FALSE.
     					*/
     					bool closeSerialCom();
					
					    /** \brief "writeSerialCom" is used to write 
					    *  commands to the controller via the open serial 
					    *  connection.
     					*
     					*  \param command[] : Contains the command to be 
     					*  sent (size of 1, 2 or 4 bytes, depending on 
     					*  the command).
     					*  \param sizeCommand : Contains the size of the 
     					*  command (1, 2 or 4).
     					*  \param response : If the command to be sent 
     					*  expects a return value from the controller, the 
     					*  writeSerialCom is given a pointer to a response 
     					*  array. This can be 1 or 2 bytes in size. If no 
     					*  return value is expected, the pointer is NULL.
     					*  \param sizeResponse : Contains the size of the 
     					*  command (1 or 2, in case of no expected return 
     					*  value it is 0).
     					*
     					*  \return Returns TRUE on successful writing to 
     					*  a serial connection, otherwise it returns FALSE.
     					*/
    					bool writeSerialCom(unsigned char command[], unsigned short sizeCommand, unsigned char *response, unsigned short sizeResponse);

					    /** \brief Returns the port HANDLE under Windows 
					    *  or the integer value for the connection under Linux.
     					*
     					*  \return port_
     					*/
    					#ifdef _WIN32
        					HANDLE getPort();
    					#else
        					int getPort();
    					#endif
					};
					
				\end{lstlisting}
				\newpage
			% Sourcefile SerialCom
			\subsection{Quellcode: Sourcefile von SerialCom} \label{SerialComCPP}
				\begin{lstlisting}[caption={[SerialCom] Klasse: SerialCom}]
					//============================================================================
					// Name        : SerialCom.cpp
					// Author      : Willi Penner
					//
					// Description : SerialCom source file. It contains the definition of the
					//               functions of the SerialCom class.
					//============================================================================
					#include "SerialCom.hpp"
					#include <stdio.h>
					#include <string>
					#include <iostream>
					
					#ifdef _WIN32
					    #include <windows.h>
					#else
						#include <fcntl.h>
						#include <unistd.h>
						#include <stdint.h>
						#include <termios.h>
						#include <stdbool.h>
					#endif
					
					/** \brief Constructors: A constructor without transfer parameters, so that when used in the Pololu class
					 *  or another class, an object of type SerialCom can be created without having to pass values to it.
					 *  And a constructor for creating an object with start parameters for the port name and the baud rate.
					 *
					 *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					 *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					 */
					SerialCom::SerialCom(){
						portName_ = "";
						baudRate_ = 0;
						#ifdef _WIN32
							port_ = NULL;
						#else
							port_ = 0;
						#endif
					}
					SerialCom::SerialCom(const char* portName, unsigned short baudRate){
						portName_ = portName;
						baudRate_ = baudRate;
						#ifdef _WIN32
							port_ = NULL;
						#else
							port_ = 0;
						#endif
					}
					
					/** \brief "initSerialCom" is used to initiate the SerialCom object with port name and baud rate.
					 *  The function puts the object in the same state as the constructor with transfer parameters.
					 *  It can be used to change the port name and the baud rate of a SerialCom object.
					 *
					 *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					 *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					 */
					void SerialCom::initSerialCom(const char* portName, unsigned short baudRate){
					    /**< Before a serial connection is reinitialized, a possible open connection is closed. */
					    #ifdef _WIN32
					        CloseHandle(port_);
					    #else
					        close(port_);
					    #endif
					    portName_ = portName;
					    baudRate_ = baudRate;
					}
					
					/** \brief Uses the set port name and the baud rate of the class to open a serial connection.
					 *  If the opening is successful, the value in "port_" stands for the open connection and
					 *  can be used for communication.
					 *
					 *  \return Returns TRUE on successful opening of a serial connection, otherwise it returns FALSE.
					 */
					bool SerialCom::openSerialCom(){
					    #ifdef _WIN32
					        /**< Opening a serial connection in windows. */
					        bool success = FALSE;
					        DCB state;
					
					        /**< If there is still an open connection, it will be closed before opening it again. */
					        CloseHandle(port_);
					        /**< Opens a serial connection using the CreateFileA function from <windows.h>. Port_ is
					        opened with read and write access. */
					        port_ = CreateFileA(portName_, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
					        if (port_ == INVALID_HANDLE_VALUE){
					            throw std::string("SerialCom::openSerialCom: Failed to open port.\n");
					            return 0;
					        }
					        /**< Flushes the file buffer of the opened connection. */
					        success = FlushFileBuffers(port_);
					        if (!success)
					        {
					            throw std::string("SerialCom::openSerialCom: Failed to flush file buffer.\n");
					            CloseHandle(port_);
					            return 0;
					        }
					        /**< Configure read and write operations to time out after 100 ms. */
					        COMMTIMEOUTS timeouts = { 0 };
					        timeouts.ReadIntervalTimeout = 0;
					        timeouts.ReadTotalTimeoutConstant = 100;
					        timeouts.ReadTotalTimeoutMultiplier = 0;
					        timeouts.WriteTotalTimeoutConstant = 100;
					        timeouts.WriteTotalTimeoutMultiplier = 0;
					        success = SetCommTimeouts(port_, &timeouts);
					        if (!success)
					        {
					            throw std::string("SerialCom::openSerialCom: Failed to set serial timeouts.\n");
					            CloseHandle(port_);
					            return 0;
					        }
					        /**< Reads the connection status of the serial connection. If the reading of
					        the connection status was successful, the baud rate for the communication is set. */
					        state.DCBlength = sizeof(DCB);
					        success = GetCommState(port_, &state);
					        if (!success)
					        {
					            throw std::string("SerialCom::openSerialCom: Failed to get serial settings.\n");
					            CloseHandle(port_);
					            return 0;
					        }
					        state.BaudRate = baudRate_;
					        success = SetCommState(port_, &state);
					        if (!success)
					        {
					            throw std::string("SerialCom::openSerialCom: Failed to set serial settings.\n");
					            CloseHandle(port_);
					            return 0;
					        }
					        return 1;
					    #else
					        bool success = false;
					
					        /**< If there is still an open connection, it will be closed before opening it again. */
					        close(port_);
					        /**< Opens a serial connection using the CreateFileA function from <windows.h>. Port_ is
					             opened with read and write access. */
					        port_ = open(portName_, O_RDWR | O_NOCTTY); //you have to set the permission for the /dev/ttyACM0
					        if (port_ == -1){
					        	throw std::string("SerialCom::openSerialCom: Failed to open port.\n");
					            return 0;
					        }
					        /**< Flushes the file buffer of the opened connection. */
					        success = tcflush(port_, TCIOFLUSH);
					        if (success){
					        	throw std::string("SerialCom::openSerialCom: Failed to flush file buffer.\n");
					        	close(port_);
					        	return 0;
					        }
					        // Get the current configuration of the serial port.
					        struct termios options;
					        success = tcgetattr(port_, &options);
					        if (success){
					        	throw std::string("SerialCom::openSerialCom: Failed to get serial settings.\n");
					            close(port_);
					            return 0;
					        }
					        // Turn off any options that might interfere with our ability to send and
					        // receive raw binary bytes.
					        options.c_iflag &= ~(INLCR | IGNCR | ICRNL | IXON | IXOFF);
					        options.c_oflag &= ~(ONLCR | OCRNL);
					        options.c_lflag &= ~(ECHO | ECHONL | ICANON | ISIG | IEXTEN);
					
					        // Set up timeouts: Calls to read() will return as soon as there is
					        // at least one byte available or when 100 ms has passed.
					        options.c_cc[VTIME] = 1;
					        options.c_cc[VMIN] = 0;
					
					        // This code only supports certain standard baud rates. Supporting
					        // non-standard baud rates should be possible but takes more work.
					        cfsetospeed(&options, B9600);
					        cfsetispeed(&options, cfgetospeed(&options));
					        success = tcsetattr(port_, TCSANOW, &options);
					        if (success){
					        	throw std::string("SerialCom::openSerialCom: Failed to set serial settings.\n");
					            close(port_);
					            return 0;
					        }
					        return 1;
					    #endif
					}
					
					/** \brief Closes a serial connection.
					 *
					 *  \return Returns TRUE on successful closing of a serial connection, otherwise it returns FALSE.
					 */
					bool SerialCom::closeSerialCom(){
					    #ifdef _WIN32
							if (CloseHandle(port_) == 0){
								throw std::string("SerialCom::closeSerialCom: Failed to close port.\n");
							    return 0;
							}
							return 1;
					    #else
							return close(port_);
					    #endif
					}
					
					/** \brief "writeSerialCom" is used to write commands to the controller via the open serial connection.
					 *
					 * \param command[] : Contains the command to be sent (size of 1, 2 or 4 bytes, depending on the command).
					 * \param sizeCommand : Contains the size of the command (1, 2 or 4).
					 * \param response : If the command to be sent expects a return value from the controller, the writeSerialCom is given a pointer to a response array. This can be 1 or 2 bytes in size. If no return value is expected, the pointer is NULL.
					 * \param sizeResponse : Contains the size of the command (1 or 2, in case of no expected return value it is 0).
					 *
					 * \return Returns TRUE on successful writing to a serial connection, otherwise it returns FALSE.
					 */
					bool SerialCom::writeSerialCom(unsigned char command[], unsigned short sizeCommand, unsigned char *response, unsigned short sizeResponse){
						//** Check the length of the command */
						if ((sizeCommand != 1) && (sizeCommand != 2) && (sizeCommand != 4)){
							throw std::string("SerialCom::writeSerialCom: wrong parameter sizeCommand, allowed parameter 1,2 or 4.");
						}
					
						#ifdef _WIN32
					        DWORD bytesTrasfered; //Is given to the write or read command as a pointer. After executing the WriteFile or ReadFile, bytesTranfered contains the number of bytes transmitted or received.
					        bool success = 0;
					
					        //** Sending the command to the controller via port_. */
					        success = WriteFile(port_, command, sizeCommand, &bytesTrasfered, NULL);
					        if (!success){
					            throw std::string("SerialCom::writeSerialCom: Failed to write to port.");
					            return 0;
					        }
					
					        //** Check whether data needs to be read. */
					        if (sizeResponse > 0){
					            success = ReadFile(port_, (void *)response, sizeResponse, &bytesTrasfered, NULL);
					        }else{
					            return 1; //No need to read data. Confirmation of the successful writing of the data.
					        }
					        if (!success){
					            throw std::string("SerialCom::writeSerialCom: Failed to read from port.");
					            return 0;
					        }
					        return 1; //Confirmation that data was written and read data were saved in the response array.
					    #else
					        //** Sending the command to the controller via port_. */
					        if(write(port_, command, sizeCommand) == -1){
					        	throw std::string("SerialCom::writeSerialCom: Failed to write to port.");
					            return 0;
					        }
					        //** Check whether data needs to be read. */
					        if (sizeResponse > 0){
					        	if(read(port_, (void *)response, sizeResponse) != sizeResponse)
					        	{
					        		throw std::string("SerialCom::writeSerialCom: Failed to read from port.");
					        		return 0;
					        	}
					        }else{
					        	return 1;
					        }
					        return 1;
					    #endif
					}
					
					/** \brief Returns the port HANDLE under Windows or the integer value for the connection under Linux.
					 *
					 * \return port_
					 */
					#ifdef _WIN32
					    HANDLE SerialCom::getPort(){
					#else
					    int SerialCom::getPort(){
					#endif
					    return port_;
					}
				\end{lstlisting}	
				\newpage
			% Interface IPololu
			\subsection{Quellcode: Headerfile von IPololu und Pololu} \label{PololuHPP}
				\begin{lstlisting}[caption={[IPololu] Interface: IPololu - Klasse: Pololu}]
					//============================================================================
					// Name        : Pololu.hpp
					// Author      : Willi Penner
					//
					// Description : Pololu header file. It contains the declaration of the
					//               IPololu interface and the Pololu class
					//============================================================================
					#ifndef POLOLU_HPP_INCLUDED
					#define POLOLU_HPP_INCLUDED
					
					#include "SerialCom.hpp"
					
					/** \brief Interface to control a Pololu controller. The interface
					 *  provides the basic functions for the control of servo motors.
					 *
					 */
					class IPololu {
					protected:
						virtual bool setPosition(unsigned short servo, unsigned short goToPosition) = 0;
						virtual bool setSpeed(unsigned short servo, unsigned short goToSpeed) = 0;
						virtual bool setAcceleration(unsigned short servo, unsigned short goToAcceleration) = 0;
						virtual unsigned short getPosition(unsigned short servo) = 0;
					public:
						virtual ~IPololu(){};
					    virtual bool getMovingState() = 0;
					};
					
					/** \brief Class for a Pololu object that contains a serial connection and provides basic functions
					 *  for programming the controller.
					 *
					 *  \param serialCom = Is an object of the SerialCom class without initialization of port name and baud rate, the "port_" is NULL.
					 */
					class Pololu : public IPololu {
					friend class ServoMotor;
					protected:
					    SerialCom serialCom;
					
					    /** \brief Funktion is used to move a specific servo to a new position.
					    *
					    *  \param servo = Servo to move
					    *  \param goToPosition = New position to be approached. The value for the new position is calculated from the position in microseconds times 4 (e.g. new position should be 1500 microseconds, then 6000 must be set in the function as new position)
					    *
					    *  \return The return value of the function is 1 if the new position was successfully set and 0 if an error occurred.
					    *
					    */
					    bool setPosition(unsigned short servo, unsigned short goToPosition);
					
					    /** \brief Function is used to set the speed for a servo with which it should move.
					    *
					    *  \param servo = Servo to set speed
					    *  \param goToSpeed = Speed of the servo (speed value 1 = 0.25us / 10ms or speed value 100 = 25us / 10ms). A speed value of 0 means infinite speed, i.e. the maximum speed of the servo.
					    *
					    *  \return The return value of the function is 1 if the new speed was successfully set and 0 if an error occurred.
					    *
					    */
					    bool setSpeed(unsigned short servo, unsigned short goToSpeed);
					
					    /** \brief Function is used to set the acceleration for a servo with which it should reach the set speed.
					    *
					    *  \param servo = Servo to set acceleration
					    *  \param goToAcceleration = Acceleration of the servo (acceleration value 1 = 0.25us / 10ms / 80ms or speed value 100 = 25us / 10ms / 80ms). A speed value of 0 means infinite acceleration, i.e. the maximum acceleration of the servo.
					    *
					    *  \return The return value of the function is 1 if the new acceleration was successfully set and 0 if an error occurred.
					    *
					    */
					    bool setAcceleration(unsigned short servo, unsigned short goToAcceleration);
					
					    /** \brief Function is used to read out the current position of a particular servo.
					    *
					    * 	\param servo = Servo whose current position is to be read out.
					    *
					    *	\return The return value is the current position of the selected servo. The position value supplied by the controller must still be multiplied by 4.
					    *
					    */
					    unsigned short getPosition(unsigned short servo);
					public:
					    /** \brief Constructor executes serialCom.initSerialCom to initialize the serial connection. An object of the Pololu class must be
					     *  initialized with the port name and baud rate using the constructor.
					     *
					     *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					     *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					     *
					     */
					    Pololu(const char* portName, unsigned short baudRate);
					
					    /** \brief Used to change the connection data. Sets the serial connection in the same state as the constructor, but with a new port name and baud rate
					     *
					     *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					     *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					     *
					     */
					    void initConnection(const char* portName, unsigned short baudRate);
					
					    /** \brief Functions are used to open and close the serial connection. Functions only call
					     * the openSerialCom and closeSerialCom functions of the serialCom object.
					     *
					     * \return Value is 1 when opening or closing was successful and 0 when an error occured.
					     *
					     */
					    bool openConnection();
					    bool closeConnection();
					
					    /** \brief Function provides the movement status of all connected servos.
					     *
					     *	\return The return value is 1 while a servo is still in motion and 0 when all servos are at a standstill.
					     *
					     */
					    bool getMovingState();
					};
					
					#endif // POLOLU_HPP_INCLUDED
				\end{lstlisting}
				\newpage
			% Sourcefile Pololu
			\subsection{Quellcode: Sourcefile von Pololu} \label{PololuCPP}
				\begin{lstlisting}[caption={[Pololu] Klasse: Pololu}]
					//============================================================================
					// Name        : Pololu.hpp
					// Author      : Willi Penner
					//
					// Description : Pololu source file. It contains the definition of the
					//               functions of the Pololu class.
					//============================================================================
					#include "Pololu.hpp"
					#include "SerialCom.hpp"
					#include <string>
					#include <iostream>
					
					/** \brief Constructor executes serialCom.initSerialCom to initialize the serial connection. An object of the Pololu class must be
					 *  initialized with the port name and baud rate using the constructor.
					 *
					 *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					 *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					 *
					 */
					Pololu::Pololu(const char* portName, unsigned short baudRate){serialCom.initSerialCom(portName, baudRate);}
					
					/** \brief Function is used to open the serial connection. Function only calls
					 * the openSerialCom function of the serialCom object.
					 *
					 * \return The return value is 1 when opening the port was successful, 0 when an error occurred.
					 *
					 */
					bool Pololu::openConnection(){
					    try
					    {
					        serialCom.openSerialCom();
					    }
					    catch (std::string &errorMessage)
					    {
					        std::cout << errorMessage;
					        return 0;
					    }
					    return 1;
					}
					
					/** \brief Function is used to close the serial connection. Function only calls
					 * the closeSerialCom function of the serialCom object.
					 *
					 * \return The return value is 1 when closing the port was successful, 0 when an error occurred.
					 *
					 */
					bool Pololu::closeConnection(){
					    try
					    {
					        serialCom.closeSerialCom();
					    }
					    catch (std::string &errorMessage)
					    {
					        std::cout << errorMessage;
					        return 0;
					    }
					    return 1;
					}
					
					/** \brief Used to change the connection data. Sets the serial connection in the same state as the constructor, but with a new port name and baud rate
					 *
					 *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					 *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					 *
					 */
					void Pololu::initConnection(const char* portName, unsigned short baudRate){serialCom.initSerialCom(portName, baudRate);}
					
					/** \brief Funktion is used to move a specific servo to a new position.
					 *
					 *  \param servo = Servo to move
					 *  \param goToPosition = New position to be approached. The value for the new position is calculated from the position in microseconds times 4 (e.g. new position should be 1500 microseconds, then 6000 must be set in the function as new position)
					 *
					 *  \return The return value of the function is 1 if the new position was successfully set and 0 if an error occurred.
					 *
					 */
					bool Pololu::setPosition(unsigned short servo, unsigned short goToPosition){
					    /* Generates the command for the controller.
					     * 0x84 = Pololu command for setting the position
					     * servo = servo to address as a transfer parameter
					     * goToPositiion = divided into 2 bytes, first the low bits, then the high bits
					     */
					    unsigned short sizeCommand = 4;
					    unsigned char command[] = {0x84, (unsigned char)servo, (unsigned char)(goToPosition & 0x7F), (unsigned char)((goToPosition >> 7) & 0x7F)};
					    try
					    {
					        serialCom.writeSerialCom(command, sizeCommand, NULL, 0);
					    }
					    catch (std::string &errorMessage)
					    {
					        throw std::string("Pololu::setPosition: " + errorMessage);
					        return 0;
					    }
					    catch(...)
					    {
					        throw std::string("Pololu::setPosition: Unknown error, while writing to port.");
					        return 0;
					    }
					    return 1;
					}
					
					/** \brief Function is used to set the speed for a servo with which it should move.
					 *
					 *  \param servo = Servo to set speed
					 *  \param goToSpeed = Speed of the servo (speed value 1 = 0.25us / 10ms or speed value 100 = 25us / 10ms). A speed value of 0 means infinite speed, i.e. the maximum speed of the servo.
					 *
					 *  \return The return value of the function is 1 if the new speed was successfully set and 0 if an error occurred.
					 *
					 */
					bool Pololu::setSpeed(unsigned short servo, unsigned short goToSpeed){
					    /* Generates the command for the controller.
					     * 0x87 = Pololu command for setting the speed
					     * servo = servo to address as a transfer parameter
					     * goToSpeed = divided into 2 bytes, first the low bits, then the high bits
					     */
					    unsigned short sizeCommand = 4;
					    unsigned char command[] = {0x87, (unsigned char)servo, (unsigned char)(goToSpeed & 0x7F), (unsigned char)((goToSpeed >> 7) & 0x7F)};
					    try
					    {
					        serialCom.writeSerialCom(command, sizeCommand, NULL, 0);
					    }
					    catch (std::string &errorMessage)
					    {
					        throw std::string("Pololu::setSpeed: " + errorMessage);
					        return 0;
					    }
					    catch(...)
					    {
					        throw std::string("Pololu::setSpeed: Unknown error, while writing to port.");
					        return 0;
					    }
					    return 1;
					}
					
					/** \brief Function is used to set the acceleration for a servo with which it should reach the set speed.
					 *
					 *  \param servo = Servo to set acceleration
					 *  \param goToAcceleration = Acceleration of the servo (acceleration value 1 = 0.25us / 10ms / 80ms or speed value 100 = 25us / 10ms / 80ms). A speed value of 0 means infinite acceleration, i.e. the maximum acceleration of the servo.
					 *
					 *  \return The return value of the function is 1 if the new acceleration was successfully set and 0 if an error occurred.
					 *
					 */
					bool Pololu::setAcceleration(unsigned short servo, unsigned short goToAcceleration){
					    /* Generates the command for the controller.
					     * 0x89 = Pololu command for setting the acceleration
					     * servo = servo to address as a transfer parameter
					     * goToAcceleration = divided into 2 bytes, first the low bits, then the high bits
					     */
					    unsigned short sizeCommand = 4;
					
					    unsigned char command[] = {0x89, (unsigned char)servo, (unsigned char)(goToAcceleration & 0x7F), (unsigned char)((goToAcceleration >> 7) & 0x7F)};
					    try
					    {
					        serialCom.writeSerialCom(command, sizeCommand, NULL, 0);
					    }
					    catch (std::string &errorMessage)
					    {
					        throw std::string("Pololu::setAcceleration: " + errorMessage);
					        return 0;
					    }
					    catch(...)
					    {
					        throw std::string("Pololu::setAcceleration: Unknown error, while writing to port.");
					        return 0;
					    }
					    return 1;
					}
					
					/** \brief Function is used to read out the current position of a particular servo.
					 *
					 * 	\param servo = Servo whose current position is to be read out.
					 *
					 *	\return The return value is the current position of the selected servo. The position value supplied by the controller must still be multiplied by 4.
					 *
					 */
					unsigned short Pololu::getPosition(unsigned short servo){
					    /* Generates the command for the controller.
					     * 0x90 = Pololu command for reading out the position
					     * servo = servo to address as a transfer parameter
					     */
					    unsigned short sizeCommand = 2;
					    unsigned short sizeResponse = 2;
					    unsigned char response[sizeResponse];
					
					    unsigned char command[] = {0x90, (unsigned char)servo};
					    try
					    {
					        serialCom.writeSerialCom(command, sizeCommand, response, sizeResponse);
					    }
					    catch (std::string &errorMessage)
					    {
					        throw std::string("Pololu::getPosition: " + errorMessage);
					    }
					    catch(...)
					    {
					        throw std::string("Pololu::getPosition: Unknown error, while writing/reading to port.");
					    }
					
					    return response[0] + 256 * response[1];
					}
					
					/** \brief Function provides the movement status of all connected servos.
					 *
					 *	\return The return value is 1 while a servo is still in motion and 0 when all servos are at a standstill.
					 *
					 */
					bool Pololu::getMovingState(){
					    /* Generates the command for the controller.
					     * 0x93 = Pololu command for reading out the movement of all servos
					     */
					    unsigned short sizeCommand = 1;
					    unsigned short sizeResponse = 1;
					    unsigned char response[sizeResponse];
					
					    unsigned char command[] = {0x93};
					    try
					    {
					        serialCom.writeSerialCom(command, sizeCommand, response, sizeResponse);
					    }
					    catch (std::string &errorMessage)
					    {
					        throw std::string("Pololu::getMovingState: " + errorMessage);
					    }
					    catch(...)
					    {
					        throw std::string("Pololu::getMovingState: Unknown error, while writing/reading to port.");
					    }
					    return response[0]; // The return value is 1 if a servo is still moving, 0 if there is no moving.
					}					
				\end{lstlisting}
				\newpage
			% Interface IServoMotor
			\subsection{Quellcode: Headerfile von IServoMotor und ServoMotor} \label{ServoMotorHPP}
				\begin{lstlisting}[caption={[IServoMotor] Interface: IServoMotor - Klasse: ServoMotor}]
					//============================================================================
					// Name        : SerialCom.hpp
					// Author      : Willi Penner
					//
					// Description : SerialCom header file. It contains the declaration of the
					//               ISerialCom interface and the SerialCom class
					//============================================================================
					#ifndef SERIALCOM_HPP_INCLUDED
					#define SERIALCOM_HPP_INCLUDED
					
					#ifdef _WIN32
					    #include <windows.h>
					#else
						#include <iostream>
					#endif
					
					/** \brief Interface for a serial connection via a COM port
					 *  Prescribes at least the included pure virtual functions for initiating,
					 *  opening, closing and writing a serial connection.
					 */
					class ISerialCom {
					public:
						virtual ~ISerialCom(){};
					    virtual void initSerialCom(const char* portName, unsigned short baudRate) = 0;
					    virtual bool openSerialCom() = 0;
					    virtual bool closeSerialCom() = 0;
					    virtual bool writeSerialCom(unsigned char command[], unsigned short sizeCommand, unsigned char *response, unsigned short sizeResponse) = 0;
					};
					
					/** \brief SerialCom is a class that inherits the functions from the ISerialCom interface.
					 *  The functionality of the interface is expanded by the function getPort ().
					 *
					 *  \param portName_ : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					 *  \param baudRate_ : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					 *  \param port_ : If a serial connection is opened successfully, depending on the operating system, a HANDLE (under Windows) or an integer value (under Linux) is defined, via which the communication takes place.
					 */
					class SerialCom : public ISerialCom {
					private:
					    const char* portName_ = NULL;
					    unsigned short baudRate_ = 0;
					    /**< depending on the operating system, a HANDLE (under Windows) or an integer value (under Linux) for an open connection */
					    #ifdef _WIN32
					        HANDLE port_;
					    #else
					        int port_;
					    #endif
					public:
					    /** \brief Constructors: A constructor without transfer parameters, so that when used in the Pololu class
					     *  or another class, an object of type SerialCom can be created without having to pass values to it.
					     *  And a constructor for creating an object with start parameters for the port name and the baud rate.
					     *
					     *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					     *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					     */
					    SerialCom();
					    SerialCom(const char* portName, unsigned short baudRate);
					
					    /** \brief "initSerialCom" is used to initiate the SerialCom object with port name and baud rate.
					     *  The function puts the object in the same state as the constructor with transfer parameters.
					     *  It can be used to change the port name and the baud rate of a SerialCom object.
					     *
					     *  \param portName : The port name is used to open a serial connection via the port name for the controller specified by the operating system.
					     *  \param baudRate : The baud rate determines the transmission speed at which communication between the PC and controller takes place.
					     */
					    void initSerialCom(const char* portName, unsigned short baudRate);
					
					    /** \brief Uses the set port name and the baud rate of the class to open a serial connection.
					     *  If the opening is successful, the value in "port_" stands for the open connection and
					     *  can be used for communication.
					     *
					     *  \return Returns TRUE on successful opening of a serial connection, otherwise it returns FALSE.
					     */
					    bool openSerialCom();
					
					    /** \brief Closes a serial connection.
					     *
					     *  \return Returns TRUE on successful closing of a serial connection, otherwise it returns FALSE.
					     */
					     bool closeSerialCom();
					
					    /** \brief "writeSerialCom" is used to write commands to the controller via the open serial connection.
					     *
					     * \param command[] : Contains the command to be sent (size of 1, 2 or 4 bytes, depending on the command).
					     * \param sizeCommand : Contains the size of the command (1, 2 or 4).
					     * \param response : If the command to be sent expects a return value from the controller, the writeSerialCom is given a pointer to a response array. This can be 1 or 2 bytes in size. If no return value is expected, the pointer is NULL.
					     * \param sizeResponse : Contains the size of the command (1 or 2, in case of no expected return value it is 0).
					     *
					     * \return Returns TRUE on successful writing to a serial connection, otherwise it returns FALSE.
					     */
					    bool writeSerialCom(unsigned char command[], unsigned short sizeCommand, unsigned char *response, unsigned short sizeResponse);
					
					    /** \brief Returns the port HANDLE under Windows or the integer value for the connection under Linux.
					     *
					     *
					     * \return port_
					     */
					    #ifdef _WIN32
					        HANDLE getPort();
					    #else
					        int getPort();
					    #endif
					};
					
					#endif // SERIALCOM_HPP_INCLUDED
										
				\end{lstlisting}
				\newpage
			% Sourcefile ServoMotor
			\subsection{Quellcode: Sourcefile ServoMotor} \label{ServoMotorCPP}
				\begin{lstlisting}[caption={[ServoMotor] Sourcefile von ServoMotor}]
					//============================================================================
					// Name        : ServoMotor.cpp
					// Author      : Willi Penner
					//
					// Description : ServoMotor source file. It contains the definition of the
					//               functions of the ServoMotor class.
					//============================================================================
					#include "ServoMotor.hpp"
					#include "Pololu.hpp"
					#include <iostream>
					#include <cmath>
					
					/** \brief ServoMotor class constructor. An object of the ServoMotor type must be initiated via the constructor.
					 *
					 * 	\param servo = is the slot number on the controller board to which the servo is connected
					 *  \param startingPosition = is the center position of the servo motor (must be determined in the Pololu Maestro Control Center)
					 *  \param delta = is the range of motion that the servo can reach from the center position
					 *  \param *connection = is a pointer to the Pololu object for the serial connection
					 *
					 * */
					ServoMotor::ServoMotor(unsigned short servo, unsigned short startingPosition, unsigned short delta, Pololu *connection){
						servoNumber_ = servo-1;
						startingPosition_ = startingPosition;
						delta_ = delta;
						connection_ = connection;
					}
					
					/** \brief Returns the port to which the servo is connected to the controller board.
					 *
					 *  \return The return value is the servoNumber+1 because the internal counting of the controller starts at 0.
					 *
					 */
					unsigned short ServoMotor::getServoNumber(){
						return servoNumber_+1;
					}
					
					/** \brief Returns the minimum position the servo is able to reach.
					 *
					 *  \return The return value is the set startingPosition minus the set delta
					 *
					 */
					unsigned short ServoMotor::getMinPos (){
						return startingPosition_ - delta_ ;
					}
					
					/** \brief Returns the center position of the servo.
					 *
					 *  \return The return value is the set startingPosition.
					 *
					 */
					unsigned short ServoMotor::getMidPos (){
						return startingPosition_;
					}
					
					/** \brief Returns the maximum position the servo is able to reach.
					 *
					 *  \return The return value is the set startingPosition plus the set delta.
					 *
					 */
					unsigned short ServoMotor::getMaxPos (){
						return startingPosition_ + delta_ ;
					}
					
					/** \brief Function causes the servo to move to a specific new position (position
					 *  is specified as an absolute value in a range from 5860 +- 3600).
					 *
					 *  \param newPosition as an absolut value
					 *
					 *  \return The return value is the return value of the setPosition funktion of the Pololu object.
					 */
					bool ServoMotor::setPositionInAbs(unsigned short newPosition){
						if (newPosition > (startingPosition_ + delta_) || newPosition < (startingPosition_ - delta_)){
							throw std::string("ServoMotor::setPositionInAbs: Abs position is out of range (startingPosition +- delta).");
						}else{
							return connection_->setPosition(servoNumber_, newPosition);
						}
					}
					
					/** \brief Function causes the servo to move to a specific new position (position is set with a value between -90 and 90 degrees).
					 *
					 *  \param newPosition in degrees
					 *
					 *  \return The return value is the return value of the setPosition funktion of the Pololu object.
					 */
					bool ServoMotor::setPositionInDeg(short newPosition){
						if (newPosition > maxDeg || newPosition < -maxDeg){
							throw std::string("ServoMotor::setPositionInDeg: Degree is out of range (-90 - 90).");
						}else{
							return connection_->setPosition(servoNumber_, startingPosition_ + newPosition * conFactorDegToPos * conFactorMyToPos);
						}
					}
					
					/** \brief Function causes the servo to move to a specific new position (position is set with a radiant between -PI/2 and PI/2).
					 *
					 *  \param newPosition as radiant
					 *
					 *  \return The return value is the return value of the setPosition funktion of the Pololu object.
					 */
					bool ServoMotor::setPositionInRad(float newPosition){
						// Since float numbers cannot be compared, the radians are converted to an int. The factor 100 sets the accuracy to 2 digits after the decimal point.
						if ((int)(100 * newPosition) > (int)(100 * (maxRad)) || (int)(100 * newPosition) < (int)(100 * (-maxRad))){
							throw std::string("ServoMotor::setPositionInRad: Radiant is out of range (-PI/2 - +PI/2).");
						}else{
							// first the neu radiant position is converted to degree (newPosition * 180 / M_PI)
							return connection_->setPosition(servoNumber_, (startingPosition_ + (newPosition * 180 / M_PI) * conFactorDegToPos * conFactorMyToPos));
						}
					}
					
					/** \brief Sets the speed at which the servo should move (speed range is between 1 and 255)
					 *
					 *  \param newSpeed = Speed value (1 is (0.25 microseconds) / (10 milliseconds),
					 *  255 is (63,75 microseconds) / (10 milliseconds))
					 *
					 *  \return The return value is the return value of the setSpeed funktion of the Pololu object.
					 */
					bool ServoMotor::setSpeed(unsigned short newSpeed){
						if (newSpeed > maxSpeed || newSpeed < minSpeed){
							throw std::string("ServoMotor::setSpeed: Speed is out of range (1 - 255).");
						}else{
							return connection_->setSpeed(servoNumber_, newSpeed);
						}
					}
					
					/** \brief Sets the acceleration with which the set speed should be reached (acceleration range is between 1 and 255)
					 *
					 *  \param newAcceleration = Acceleration value (1 is (0.25 microseconds) / (10 milliseconds) / (80 milliseconds),
					 *  255 is (63,75 microseconds) / (10 milliseconds) / (80 milliseconds))
					 *
					 *  \return The return value is the return value of the setAcceleration funktion of the Pololu object.
					 */
					bool ServoMotor::setAccelaration(unsigned short newAcceleration){
						if (newAcceleration > maxAcceleration || newAcceleration < minAcceleration){
							throw std::string("ServoMotor::setAcceleration: Acceleration is out of range (1 - 255).");
						}else{
							return connection_->setAcceleration(servoNumber_, newAcceleration);
						}
					}
					
					/** \brief Returns the position of the servo as absolute value.
					 *
					 *  \return The return value is the return value of the getPosition function of the Pololu object.
					 *
					 */
					unsigned short ServoMotor::getPositionInAbs(){
						return connection_->getPosition(servoNumber_);
					}
					
					/** \brief Returns the position of the servo in degrees.
					 *
					 *  \return The return value is the return value of the getPosition function of the Pololu object converted into degrees.
					 *
					 */
					short ServoMotor::getPositionInDeg(){
						return (connection_->getPosition(servoNumber_) / conFactorMyToPos - startingPosition_) / conFactorDegToPos;
					}
					
					/** \brief Returns the position of the servo as radiant.
					 *
					 *  \return The return value is the return value of the getPosition function of the Pololu object converted into radiant.
					 *
					 */
					float ServoMotor::getPositionInRad(){
						return (connection_->getPosition(servoNumber_) / conFactorMyToPos - startingPosition_) * M_PI / conFactorDegToPos / 180;
					}
					
					/** \brief Shows which settings have to be made in the Pololu Maestro Control Center for the servo,
					 *  based on the starting position and the delta for the specific servo.
					 */
					void ServoMotor::showPololuValues (unsigned short& min, unsigned short& mid, unsigned short& max){
						min = (unsigned short)((startingPosition_ - delta_) / conFactorMyToPos);
						max = (startingPosition_ + delta_) / conFactorMyToPos;
						mid = (startingPosition_) / conFactorMyToPos;
					}
				\end{lstlisting}
				\newpage
			% Headerfile TestUnits
			\subsection{Quellcode: Headerfile TestUnits.hpp} \label{TestUnitsHPP}
				\begin{lstlisting}[caption={[TestUnits] Headerfile von TestUnits}]
					//============================================================================
					// Name        : TestUnits.hpp
					// Author      : Willi Penner
					//
					// Description :
					//============================================================================
					#ifndef TESTUNITS_HPP_
					#define TESTUNITS_HPP_
					
					void wait(unsigned long milliseconds);
					void testOpenClose ();
					void testSetGetMethods ();
					void testMEXMovementSetting1 ();
					void testMEXMovementSetting2 ();
					
					#endif /* TESTUNITS_HPP_ */
				\end{lstlisting}
				\newpage
			% Sourcefile TestUnits
			\subsection{Quellcode: Sourcefile TestUnits.spp} \label{TestUnitsSPP}
				\begin{lstlisting}[caption={[TestUnits] Sourcefile von TestUnits}]
					//============================================================================
					// Name        : TestUnits.cpp
					// Author      : Willi Penner
					//
					// Description :
					//============================================================================
					#include "Pololu.hpp"
					#include "SerialCom.hpp"
					#include "ServoMotor.hpp"
					#include <string>
					#include <iostream>
					#include <cmath>
					
					using namespace std;
					
					#ifdef _WIN32
					    #include <windows.h>
					#else
						#include <unistd.h>
					#endif
					
					/** \brief The function is used for waiting for a certain time, depending on the operating system Sleep () or usleep () is used.
					 *
					 *	\param milliseconds = Time to wait in milliseconds
					 *
					 */
					void wait(unsigned long milliseconds){
						#ifdef _WIN32
							Sleep(milliseconds);
						#else
							usleep(milliseconds);
						#endif
					}
					
					/** \brief Function systematically tests the opening and closing of a serial connection
					 *
					 */
					void testOpenClose (){
					    //Define the port name and the baud rate
						#ifdef _WIN32
							const char* portName = "COM5";  		// Windows
						#else
							const char* portName = "/dev/ttyACM0";  // Linux
						#endif
						unsigned short baudRate = 9600;
					    //Define a Pololu object
					    Pololu conn(portName, baudRate);
					
					    /**< Test 1 */
					    //Open the serial port with the initialized port name and baud rate
					    std::cout << "TEST_01 :: ";
					    if (conn.openConnection()){
					        std::cout << portName << ": Connection opened successfully" << std::endl;
					    }
					    //Open the same port again
					    std::cout << "TEST_01 :: ";
					    if (conn.openConnection()){
					        std::cout << portName << ": Connection opened successfully" << std::endl;
					    }
					
					    /**< Test 2 */
					    //Close the port
					    std::cout << "TEST_02 :: ";
					    if (conn.closeConnection()){
					        std::cout << portName << ": Connection closed successfully" << std::endl;
					    }
					    //Close the same port again
					    std::cout << "TEST_02 :: ";
					    if (conn.closeConnection()){
					        std::cout << portName << ": Connection closed successfully" << std::endl;
					    }
					
					    /**< Test 3 */
					    //Reinitialize the serial port with an unknown name
					    conn.initConnection("COM7", baudRate);
					    //Open the newly initialized port
					    std::cout << "TEST_03 :: ";
					    if (conn.openConnection()){
					        std::cout << "COM7" << ": Connection opened successfully" << std::endl;
					    }
					
					    /**< Test 4 */
					    //Reinitialize the serial port with a known port, but not from the Pololu
					    conn.initConnection("COM1", baudRate);
					    //Open the port
					    std::cout << "TEST_04 :: ";
					    if (conn.openConnection()){
					        std::cout << "COM1" << ": Connection opened successfully" << std::endl;
					    }
					    //Close the port
					    std::cout << "TEST_04 :: ";
					    if (conn.closeConnection()){
					        std::cout << portName << ": Connection closed successfully" << std::endl;
					    }
					
					    /**< Test 5 */
					    //Reinitialize the serial port with a Pololu known port
					    conn.initConnection(portName, baudRate);
					    for (int i = 0; i < 100; i++){
					    	std::cout << "TEST_05_" << i << " :: ";
					        if (conn.openConnection()){
					            std::cout << portName << ": Connection opened successfully" << std::endl;
					        }
					    }
					    conn.closeConnection();
					}
					
					/** \brief Function systematically tests the writing and reading of a serial connection.
					 *  This function is not suitable for testing the methods on the robot manipulator.
					 *  Please use it on a stand alone controller.
					 *
					 *  Settings for the servo motors in the Pololu Control Center:
					 *  Serial Settings:
					 *      Serial mode: USB Dual Port
					 *  Channelsettings:
					 *      NAME       | Min       | Max        | 8-bit neutral
					 *      SERVO_01   | 480       | 2400       | 1500
					 *      SERVO_02   | 480       | 2400       | 1500
					 *      SERVO_04   | 480       | 2400       | 1500
					 *
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  Please check the values in the Pololu Control Center first
					 *
					 */
					void testSetGetMethods (){
						// Define the port name and the baud rate
						#ifdef _WIN32
							const char* portName = "COM4";  		// Windows
						#else
							const char* portName = "/dev/ttyACM0";  // Linux
						#endif
					    // Defines a serial connections and opens it.
						Pololu conn(portName, 9600);
						conn.openConnection();
					
						// Defines three servomotors of two different types.
						// ServoMotor name(<portnumber on the controller>, <middle position of the servo>, <movement range in one direction>, <pointer to the serial connection>)
						ServoMotor SG_90_1(1, 5680, 3600, &conn);
						ServoMotor SG_90_2(2, 5680, 3600, &conn);
						ServoMotor DM1500_1(4, 5680, 3600, &conn);
						unsigned short servoMin = 0;
						unsigned short servoMid = 0;
						unsigned short servoMax = 0;
					
						// Shows the min-, max-position and the 8bit-neutral for the servo channelsettings for the pololu controller.
						// The values have to be the same as in the Pololu Maestro Control Center.
						//
						// For example:
						// Pololu values for the servo channel settings at port 2:
						// Min:          520 microseconds
						// Max:          2320 microseconds
						// 8bit neutral: 1420 microseconds
						SG_90_1.showPololuValues(servoMin, servoMid, servoMax);
						cout << "Pololu values for the servo channel settings at port " << SG_90_1.getServoNumber() << ":" << endl;
						cout << "Min:          " << servoMin << endl;
						cout << "Max:          " << servoMax << endl;
						cout << "8bit neutral: " << servoMid << endl << endl;
						//SG_90_2.showPololuValues(servoMin, servoMid, servoMax);
						//DM1500_1.showPololuValues(servoMin, servoMid, servoMax);
					
						// Shows the min-,  mid- and max-position of the defined servos
						cout << "SERVO: SG_90_1 | SG_90_2 | DM1500_1 \n" << "Min:   " << SG_90_1.getMinPos() << "      " << SG_90_2.getMinPos() << "      " << DM1500_1.getMinPos()
								<< "\nMid:   " << SG_90_1.getMidPos() << "      " << SG_90_2.getMidPos() << "      " << DM1500_1.getMidPos() << "\nMax:   " << SG_90_1.getMaxPos()
								<< "      " << SG_90_2.getMaxPos() << "      " << DM1500_1.getMaxPos() << endl;
					
						// Set speed and acceleration for all servos
						SG_90_1.setSpeed(30);
						SG_90_1.setAccelaration(30);
						SG_90_2.setSpeed(30);
						SG_90_2.setAccelaration(30);
						DM1500_1.setSpeed(30);
						DM1500_1.setAccelaration(30);
					
						// Moves the servo 1 to the minimum or maximum position depending on the starting position.
						if (SG_90_1.getPositionInAbs() < SG_90_1.getMidPos()){
							SG_90_1.setPositionInAbs(SG_90_1.getMaxPos());
						}else{
							SG_90_1.setPositionInAbs(SG_90_1.getMinPos());
						}
						// Moves the servo 2 to the minimum or maximum position depending on the starting position.
						if (SG_90_2.getPositionInAbs() < SG_90_2.getMidPos()){
							SG_90_2.setPositionInAbs(SG_90_2.getMaxPos());
						}else{
							SG_90_2.setPositionInAbs(SG_90_2.getMinPos());
						}
						// Moves the servo 3 to the minimum or maximum position depending on the starting position (5 times).
						for (int i = 0; i < 5; i++){
							if (DM1500_1.getPositionInAbs() < DM1500_1.getMidPos()){
								DM1500_1.setPositionInAbs(DM1500_1.getMaxPos());
								while(conn.getMovingState());
							}else{
								DM1500_1.setPositionInAbs(DM1500_1.getMinPos());
								while(conn.getMovingState());
							}
						}
					
						// Moves servo 3 to the position of zero degree.
						DM1500_1.setPositionInDeg(0);
						while(conn.getMovingState());
						// Moves servo 3 to the position of maximum abs position.
						DM1500_1.setPositionInAbs(DM1500_1.getMaxPos());
						while(conn.getMovingState());
						// Moves servo 3 to the position of -45 degree.
						DM1500_1.setPositionInDeg(-45);
						while(conn.getMovingState());
						// Moves servo 3 to the position of PI/2 radiant.
						DM1500_1.setPositionInRad(-1.5);
						while(conn.getMovingState());
						// Moves servo 3 to the position of zero radiant.
						DM1500_1.setPositionInRad(0.0);
						while(conn.getMovingState());
					
						// Closes the connection.
						conn.closeConnection();
					}
					
					/** \brief Function for testing the fully assembled MEX robot manipulator.
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *
					 *  This function may only be carried out on the MEX system under certain general conditions.
					 *	Please check the settings in the Pololu Maestro Control Center first.
					 *
					 *  Settings for the servo motors in the Pololu Control Center:
					 *  Serial Settings:
					 *      Serial mode: USB Dual Port
					 *  Channelsettings:
					 *      NAME       | Min       | Max        | 8-bit neutral
					 *      SERVO_01   | 512       | 2400       | 1420
					 *      SERVO_02   | 512       | 2400       | 1500
					 *      SERVO_03   | 512       | 2400       | 1470
					 *      SERVO_04   | 480       | 1504       | 952
					 * Status: set the servo to following positions(parking position)
					 *      NAME       | Target
					 *      SERVO_01   | 1420
					 *      SERVO_02   | 710
					 *      SERVO_03   | 1470
					 *      SERVO_04   | 952
					 *
					 */
					void testMEXMovementSetting1(){
					    unsigned short speed = 100;
					    unsigned short acceleration = 10;
					    // Define the port name and the baud rate
					   	#ifdef _WIN32
					   		const char* portName = "COM5";  		// Windows
					   	#else
					   		const char* portName = "/dev/ttyACM2";  // Linux
					   	#endif
					    Pololu conn(portName, 9600);
					
					    // Open connection to COM port.
					    conn.openConnection();
					
					    // Define the servos of the robot manipulator
					    ServoMotor base(1, 5680, 3600, &conn);
					    ServoMotor arm_1(2, 6000, 3600, &conn);
					    ServoMotor arm_2(3, 5880, 3600, &conn);
					    ServoMotor grip(4, 3808, 1888, &conn);
					
					    wait(1000);
					
					    // Set speed and acceleration for all servos
					    base.setSpeed(speed);
					    base.setAccelaration(acceleration);
					    arm_1.setSpeed(speed);
					    arm_1.setAccelaration(acceleration);
					    arm_2.setSpeed(speed);
					    arm_2.setAccelaration(acceleration);
					    grip.setSpeed(speed);
					    grip.setAccelaration(acceleration);
					
					    // Go to parking position
					    base.setPositionInAbs(5680);
					    arm_1.setPositionInAbs(2840);
					    arm_2.setPositionInAbs(5880);
					    grip.setPositionInAbs(3808);
					    while(conn.getMovingState());
					
					    // Go to start position
					    arm_1.setPositionInAbs(6000);
					    while(conn.getMovingState());
					
					    //Move into grabbing position
					    base.setPositionInAbs(3600);
					    arm_1.setPositionInAbs(4000);
					    while(conn.getMovingState());
					    grip.setPositionInAbs(4800);
					    arm_2.setPositionInAbs(arm_2.getMinPos());
					    arm_1.setPositionInAbs(4800);
					    while(conn.getMovingState());
					
					    // Grab
					    grip.setPositionInAbs(3320);
					    while(conn.getMovingState());
					    // Lift
					    arm_1.setPositionInAbs(4000);
					    while(conn.getMovingState());
					
					    // Move to new Location
					    base.setPositionInAbs(8000);
					    while(conn.getMovingState());
					
					    // Drop
					    arm_1.setPositionInAbs(4700);
					    while(conn.getMovingState());
					    grip.setPositionInAbs(4800);
					    while(conn.getMovingState());
					    arm_1.setPositionInAbs(4000);
					    while(conn.getMovingState());
					
					    // Go to start position
					    base.setPositionInAbs(5680);
					    while(conn.getMovingState());
					    arm_1.setPositionInAbs(6000);
					    arm_2.setPositionInAbs(5880);
					    grip.setPositionInAbs(3808);
					    while(conn.getMovingState());
					
					    // Wave
					    grip.setSpeed(100);
					    grip.setAccelaration(100);
					    arm_2.setPositionInDeg(90);
					    while(conn.getMovingState());
					    for (int i = 0; i < 8; i++){
					        if (grip.getPositionInAbs() > grip.getMidPos()){
					        	grip.setPositionInAbs(grip.getMinPos());
					        	while(conn.getMovingState());
					        }else{
					        	grip.setPositionInAbs(grip.getMaxPos());
					        	while(conn.getMovingState());
					        }
					    }
					    arm_2.setPositionInDeg(0);
					    grip.setSpeed(speed);
					    grip.setAccelaration(acceleration);
					
					    // Go to Parking Position
					    arm_1.setPositionInAbs(2840);
					
					    // Close the serial Connection
					    conn.closeConnection();
					}
					
					/** \brief Function for testing the fully assembled MEX robot manipulator.
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *  WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING - WARNING
					 *
					 *  This function may only be carried out on the MEX system under certain general conditions.
					 *	Please check the settings in the Pololu Maestro Control Center first.
					 *
					 *  Settings for the servo motors in the Pololu Control Center:
					 *  Serial Settings:
					 *      Serial mode: USB Dual Port
					 *  Channelsettings:
					 *      NAME       | Min       | Max        | 8-bit neutral
					 *      SERVO_01   | 660       | 2460       | 1560
					 *      SERVO_02   | 640       | 2540       | 1640
					 *      SERVO_03   | 610       | 2410       | 1510
					 *      SERVO_04   | 496       | 980        | 496
					 * Status: set the servo to following positions(parking position)
					 *      NAME       | Target
					 *      SERVO_01   | 1560
					 *      SERVO_02   | 1640
					 *      SERVO_03   | 1510
					 *      SERVO_04   | 496
					 *
					 */
					void testMEXMovementSetting2(){
					    unsigned short speed = 2;
					    unsigned short acceleration = 200;
					    // Define the port name and the baud rate
					   	#ifdef _WIN32
					   		const char* portName = "COM5";  		// Windows
					   	#else
					   		const char* portName = "/dev/ttyACM2";  // Linux
					   	#endif
					    Pololu conn(portName, 9600);
					
					    // Open connection to COM port.
					    conn.openConnection();
					
					    // Define the servos of the robot manipulator
					    ServoMotor arm_0(1, 6240, 3600, &conn);
					    ServoMotor arm_1(2, 6560, 3600, &conn);
					    ServoMotor arm_2(3, 6160, 3600, &conn);
					    ServoMotor arm_3(4, 2944, 960, &conn);
					
					    wait(1000);
					
					    // Set speed and acceleration for all servos
					    arm_0.setSpeed(speed);
					    arm_0.setAccelaration(acceleration);
					    arm_1.setSpeed(speed);
					    arm_1.setAccelaration(acceleration);
					    arm_2.setSpeed(speed);
					    arm_2.setAccelaration(acceleration);
					    arm_3.setSpeed(speed);
					    arm_3.setAccelaration(acceleration);
					    while(conn.getMovingState());
					
					    // Move into starting position
					    arm_0.setPositionInAbs(arm_0.getMidPos());
					    arm_1.setPositionInAbs(arm_1.getMidPos());
					    arm_2.setPositionInAbs(arm_2.getMidPos());
					    arm_3.setPositionInAbs(arm_3.getMinPos());
					    while(conn.getMovingState());
					
					    wait(5000);
					
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					    // Point top
					    arm_0.setPositionInAbs(6792);
					    arm_1.setPositionInAbs(5800);
					    arm_2.setPositionInAbs(9040);
					    while(conn.getMovingState());
					
					    arm_3.setPositionInAbs(3100);
					    while(conn.getMovingState());
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					
					    // Point top left
					    arm_0.setPositionInAbs(5704);
					    arm_1.setPositionInAbs(4752);
					    arm_2.setPositionInAbs(9452);
					    while(conn.getMovingState());
					
					    arm_3.setPositionInAbs(3200);
					    while(conn.getMovingState());
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					
					    // Point bottom left
					    arm_0.setPositionInAbs(4404);
					    arm_1.setPositionInAbs(3860);
					    arm_2.setPositionInAbs(9600);
					    while(conn.getMovingState());
					
					    arm_3.setPositionInAbs(3300);
					    while(conn.getMovingState());
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					
					    // Point bottom right
					    arm_0.setPositionInAbs(4544);
					    arm_1.setPositionInAbs(3880);
					    arm_2.setPositionInAbs(8856);
					    while(conn.getMovingState());
					
					    arm_3.setPositionInAbs(3300);
					    while(conn.getMovingState());
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					
					    // Point top right
					    arm_0.setPositionInAbs(5840);
					    arm_1.setPositionInAbs(4800);
					    arm_2.setPositionInAbs(8780);
					    while(conn.getMovingState());
					
					    arm_3.setPositionInAbs(3200);
					    while(conn.getMovingState());
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					
					    // Point top
					    arm_0.setPositionInAbs(6792);
					    arm_1.setPositionInAbs(5800);
					    arm_2.setPositionInAbs(9040);
					    while(conn.getMovingState());
					
					    arm_3.setPositionInAbs(3100);
					    while(conn.getMovingState());
					    arm_3.setPositionInAbs(2400);
					    while(conn.getMovingState());
					
					    // Move into starting position
					    arm_0.setPositionInAbs(arm_0.getMidPos());
					    arm_1.setPositionInAbs(arm_1.getMidPos());
					    arm_2.setPositionInAbs(arm_2.getMidPos());
					    arm_3.setPositionInAbs(arm_3.getMinPos());
					    while(conn.getMovingState());
					
					
					    // Close the serial Connection
					    conn.closeConnection();
					}
					
					void testSerialCom(){
						SerialCom serialCom1;
						SerialCom serialCom2("COM4", 9600);
					
						if (serialCom1.getPort() == NULL){
							cout << "COM1: No port established" << endl;
						}else{
							cout << "COM1: " << serialCom1.getPort() << endl;
						}
						if (serialCom2.getPort() == NULL){
							cout << "COM2: No port established" << endl;
						}else{
							cout << "COM2: " << serialCom2.getPort() << endl;
						}
					
						try{
							serialCom1.openSerialCom();
							cout << "COM1: " << serialCom1.getPort() << endl;
						}catch (std::string &errorMessage){
					        std::cout << "COM1: " << errorMessage;
					    }
					
						try{
							serialCom2.openSerialCom();
							cout << "COM2: " << serialCom1.getPort() << endl;
						}catch (std::string &errorMessage){
						    std::cout << "COM2: " << errorMessage;
						}
					
						try{
							serialCom1.initSerialCom("COM7",9600);
							std::cout << "COM7: initialized" << endl;
						}catch (std::string &errorMessage){
						    std::cout << "COM7: " << errorMessage;
						}
					
						try{
							serialCom1.openSerialCom();
							cout << "COM7: " << serialCom1.getPort() << endl;
						}catch (std::string &errorMessage){
						    std::cout << "COM7: " << errorMessage;
						}
					
						unsigned char command[4];
						command[0] = 0x84;
						command[1] = (unsigned char)3;
						command[2] = (unsigned char)(6000 & 0x7F);
						command[3] = (unsigned char)((6000 >> 7) & 0x7F);
						serialCom2.writeSerialCom(command, 4, NULL, 0);
					
						unsigned char commandRead[2];
						commandRead[0] = 0x90;
						commandRead[1] = (unsigned char)3;
						unsigned char response[2];
						serialCom2.writeSerialCom(commandRead, 2, response, 2);
						cout << "COM2: Servo 4 is at position " << response[0] + 256 * response[1] ;
					}
					
					void testPololu(){
						Pololu conn("COM4", 9600);
					
						try{
							conn.openConnection();
							cout << "Pololutest: Connection opened" << endl;
						}catch (std::string &errorMessage){
						    std::cout << "Pololutest: " << errorMessage;
						}
					
						/*try{
							conn.setPosition(3, 2400);
							cout << "Pololutest: Position set" << endl;
						}catch (std::string &errorMessage){
						    std::cout << "Pololutest: " << errorMessage;
						}*/
					
						try{
							conn.openConnection();
							cout << "Pololutest: Connection closed" << endl;
						}catch (std::string &errorMessage){
						    std::cout << "Pololutest: " << errorMessage;
						}
					}
				
				\end{lstlisting}
				\newpage		
			% Aufbauanleitung der Projektgruppe
			\subsection{Aufbauanleitung MEX} \label{Aufbauanleitung} 
				\includegraphics[page=1,width=1.1\textwidth]{Aufbau01.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau02.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau03.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau04.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau05.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau06.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau07.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau08.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau09.pdf}  
				\newpage
				\includegraphics[page=1,width=\textwidth]{Aufbau10.pdf}  
				\newpage	
			
\end{document}
